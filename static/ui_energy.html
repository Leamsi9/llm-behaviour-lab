<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Energy Testing Lab - LLM Behavior Lab</title>
  <script src="/static/tailwind.min.js"></script>
  <script src="/static/chart.min.js"></script>
  <style>
    /* Modern Dark Dashboard Theme */
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --secondary: #8b5cf6;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --bg-dark: #0f172a;
      --bg-darker: #020617;
      --bg-card: #1e293b;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --border: #334155;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--bg-darker) 0%, var(--bg-dark) 100%);
      color: var(--text-primary);
      min-height: 100vh;
    }

    .dashboard-card {
      background: var(--bg-card);
      border-radius: 16px;
      border: 1px solid var(--border);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }

    .dashboard-card:hover {
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
      border-color: var(--primary);
    }

    .nav-button {
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(10px);
      border: 2px solid transparent;
      border-radius: 16px;
      padding: 1rem 1.5rem;
      color: var(--text-secondary);
      font-weight: 600;
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 1px rgba(255, 255, 255, 0.1);
    }

    .nav-button::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, #6366f1, #8b5cf6, #ec4899, #f59e0b);
      background-size: 300% 300%;
      border-radius: 16px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: -1;
    }

    .nav-button::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.3), transparent);
      transition: left 0.5s;
    }

    .nav-button:hover::after {
      left: 100%;
    }

    .nav-button:hover {
      color: var(--text-primary);
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4), inset 0 1px 1px rgba(255, 255, 255, 0.2);
    }

    .nav-button.active {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%);
      color: white;
      box-shadow: 0 8px 30px rgba(99, 102, 241, 0.6), 0 0 40px rgba(99, 102, 241, 0.3), inset 0 1px 1px rgba(255, 255, 255, 0.2);
    }

    .nav-button.active::before {
      opacity: 1;
      animation: borderGlow 3s linear infinite;
    }

    @keyframes borderGlow {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    .metric-card {
      background: linear-gradient(135deg, var(--bg-card) 0%, #2d3748 100%);
      border-radius: 12px;
      padding: 1.5rem;
      border: 1px solid var(--border);
      transition: all 0.3s ease;
    }

    .metric-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
    }

    .metric-value {
      font-size: 2rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(99, 102, 241, 0.5);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
    }

    .section-content {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    .section-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .glow {
      box-shadow: 0 0 20px rgba(99, 102, 241, 0.5);
    }

    input,
    textarea,
    select {
      background: var(--bg-darker) !important;
      border: 1px solid var(--border) !important;
      color: var(--text-primary) !important;
      border-radius: 8px;
      padding: 0.75rem;
      transition: all 0.3s ease;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--primary) !important;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
      background: var(--bg-dark) !important;
    }

    input::placeholder,
    textarea::placeholder {
      color: var(--text-secondary);
      opacity: 0.6;
    }

    /* Ensure select options are also dark */
    select option {
      background: var(--bg-darker);
      color: var(--text-primary);
    }

    input[type="number"] {
      -moz-appearance: textfield;
    }

    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      opacity: 0.5;
    }

    /* Checkbox styling for dark mode */
    input[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 1.25rem;
      height: 1.25rem;
      border: 2px solid var(--border) !important;
      border-radius: 4px;
      background: var(--bg-darker) !important;
      cursor: pointer;
      position: relative;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    input[type="checkbox"]:hover {
      border-color: var(--primary) !important;
      background: var(--bg-dark) !important;
    }

    input[type="checkbox"]:checked {
      background: var(--primary) !important;
      border-color: var(--primary) !important;
    }

    input[type="checkbox"]:checked::after {
      content: '';
      position: absolute;
      left: 4px;
      top: 1px;
      width: 5px;
      height: 10px;
      border: solid white;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }

    input[type="checkbox"]:focus {
      outline: none;
      border-color: var(--primary) !important;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2) !important;
    }

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-darker);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--primary);
    }
  </style>
</head>

<body class="p-6">
  <div class="max-w-7xl mx-auto">

    <!-- Header -->
    <div class="mb-8">
      <h1 class="text-4xl font-bold mb-2 bg-gradient-to-r from-indigo-400 to-purple-400 bg-clip-text text-transparent">
        ‚ö° LLM Energy Testing Lab
      </h1>
      <p class="text-slate-400">Measure real-world energy consumption and carbon footprint of LLM interactions</p>
    </div>

    <!-- Navigation Dashboard (Sticky) -->
    <div class="sticky top-0 z-40 bg-gradient-to-b from-slate-950 to-transparent pb-4 mb-8">
      <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
        <button class="nav-button active" onclick="toggleSection('prompt-model')" data-section="prompt-model">
          <div class="text-2xl mb-2">üéØ</div>
          <div class="text-sm">Prompt Model</div>
        </button>
        <button class="nav-button" onclick="toggleSection('middleware')" data-section="middleware">
          <div class="text-2xl mb-2">üß©</div>
          <div class="text-sm">Middleware</div>
        </button>
        <button class="nav-button" onclick="toggleSection('response')" data-section="response">
          <div class="text-2xl mb-2">üí¨</div>
          <div class="text-sm">Response</div>
        </button>
        <button class="nav-button" onclick="toggleSection('results')" data-section="results">
          <div class="text-2xl mb-2">üìà</div>
          <div class="text-sm">Tests</div>
        </button>
        <a href="/documentation" target="_blank" rel="noopener noreferrer"
          class="nav-button flex flex-col items-start justify-center"
          title="Open the full documentation for concepts, installation, API endpoints, and troubleshooting.">
          <div class="text-2xl mb-2">üìö</div>
          <div class="text-sm">Documentation</div>
        </a>
      </div>
    </div>

    <!-- Test Controls (Always Visible) -->
    <div class="dashboard-card p-4 mb-6 sticky top-32 z-30 shadow-xl border-t border-slate-700">
      <div class="flex flex-wrap items-center gap-4">
        <button id="runTest" class="btn-primary flex items-center gap-2">
          <span class="text-lg">‚ö°</span> Run Energy Test
        </button>

        <button id="stopTest" disabled class="btn bg-slate-700 text-slate-400 px-4 py-2 rounded-lg cursor-not-allowed">
          Stop
        </button>

        <div class="h-8 w-px bg-slate-600"></div>

        <label class="flex items-center gap-2 cursor-pointer">
          <input type="checkbox" id="enableLivePower" class="w-4 h-4 text-indigo-600 rounded">
          <span class="text-sm font-medium">Enable Live Power (RAPL)</span>
        </label>

        <div class="ml-auto flex gap-2">
          <button id="showLogs" class="text-slate-400 hover:text-white text-sm">üìã Logs</button>
          <button id="clearResults" class="text-slate-400 hover:text-red-400 text-sm">üóëÔ∏è Clear</button>
          <button id="exportData" class="text-slate-400 hover:text-indigo-400 text-sm">üíæ Export</button>
        </div>
      </div>
    </div>

    <!-- Section: Prompt Model -->
    <div id="section-prompt-model" class="section-content active">
      <div class="dashboard-card p-6 space-y-6">
        <h2 class="text-2xl font-bold flex items-center gap-2">
          <span>üéØ</span> Prompt Model
          <span class="text-xs text-slate-400 cursor-help"
            title="Choose which LLM provider and model to run for this test. Local (Ollama) supports live RAPL measurements; Cloud (Groq) uses benchmark-based estimates only.">‚ìò</span>
        </h2>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <label class="block text-sm font-semibold mb-2 cursor-help"
              title="Select where inference runs. Local (Ollama) talks to your own models; Cloud (Groq) uses hosted models and disables direct RAPL hardware measurements.">Provider</label>
            <select id="modelProviderSelect" class="w-full mb-3">
              <option value="local">üñ•Ô∏è Local (Ollama)</option>
              <option value="cloud">‚òÅÔ∏è Cloud (Groq)</option>
            </select>
            <label class="block text-sm font-semibold mb-2 cursor-help"
              title="Pick the concrete model to benchmark. Context length and energy profile depend strongly on this choice.">Model
              Selection</label>
            <select id="modelSelect" class="w-full">
              <option>Loading models‚Ä¶</option>
            </select>
            <div id="modelInfo" class="mt-2 text-xs text-slate-400 hidden">
              <div class="flex items-center gap-2">
                <span>üìä Context Length:</span>
                <span id="modelContextLength" class="font-mono text-indigo-400">-</span>
              </div>
            </div>
            <div id="cloudProviderNote" class="mt-2 text-xs text-amber-400 hidden">
              ‚ö†Ô∏è RAPL power monitoring disabled for cloud models. Energy estimates only.
            </div>
          </div>
        </div>

        <div>
          <label class="block text-sm font-semibold mb-2 cursor-help"
            title="The actual task you care about. These are the only truly \"original\" tokens; everything added in Middleware counts as hidden overhead.">User
            Query</label>
          <textarea id="userPrompt" class="w-full h-32 resize-y font-mono text-sm"
            placeholder="Explain quantum computing in simple terms."></textarea>
          <div class="text-xs text-slate-500 mt-2 flex items-center">
            üí° This is your actual query - the only "original" tokens
          </div>
        </div>
      </div>
    </div>

    <!-- Section: Middleware -->
    <div id="section-middleware" class="section-content">
      <div class="dashboard-card p-6 space-y-6">
        <h2 class="text-2xl font-bold flex items-center gap-2">
          <span>üß©</span> Hidden Middleware
          <span class="text-xs text-slate-400 cursor-help"
            title="System prompts, conversation context, and injections add invisible tokens that change behaviour and increase prefill energy. Use this panel to experiment with middleware overhead.">‚ìò</span>
        </h2>

        <div class="bg-blue-900/30 border border-blue-700/50 rounded-lg p-4 text-sm">
          <strong>‚ö†Ô∏è Middleware Overhead:</strong> Each injection adds hidden tokens to your query
        </div>

        <!-- System Prompt -->
        <div class="space-y-4">
          <h3 class="text-lg font-semibold border-b border-slate-700 pb-2 cursor-help"
            title="Tokens added before generation (system prompt, context, injections). Their length drives prefill energy and can dominate Wh for very long prompts.">Inputs
            (Prefill Stage)</h3>

          <div>
            <div class="flex justify-between items-center mb-2">
              <label class="text-sm font-semibold cursor-help"
                title="High-level role and behaviour instructions for the model. Presets come from reference system prompts; custom text lets you prototype your own middleware.">System
                Prompt</label>
              <div class="flex gap-2">
                <select id="systemPromptSelect" class="text-xs p-1.5">
                  <option value="">Custom / empty</option>
                </select>
                <button id="clearSystemPromptBtn" class="text-xs text-red-400 hover:text-red-300 px-2">Clear</button>
              </div>
            </div>
            <textarea id="systemPromptText" class="w-full h-24 text-sm font-mono"
              placeholder="Optional system prompt or middleware instructions"></textarea>
          </div>

          <div>
            <div class="flex justify-between items-center mb-2">
              <label class="text-sm font-semibold cursor-help"
                title="Optional prior messages or history. Wrapped in &lt;conversation_context&gt; tags and added before your new query, increasing prefill tokens.">Conversation
                Context</label>
              <button id="injectConversationBtn" class="text-xs bg-indigo-600 hover:bg-indigo-700 px-3 py-1.5 rounded">
                Inject Last Turn
              </button>
            </div>
            <textarea id="conversationContextText" class="w-full h-24 text-sm font-mono"
              placeholder="Conversation context will be wrapped in <conversation_context> tags."></textarea>
          </div>

          <div id="injectionsContainer" class="space-y-3"></div>
          <button id="addInjectionBtn"
            class="w-full py-2 border-2 border-dashed border-slate-600 rounded-lg hover:border-indigo-500 transition-all flex items-center justify-center gap-2">
            <span>‚ûï</span> Add Prompt Injection
          </button>
        </div>

        <!-- Outputs -->
        <div class="space-y-4">
          <h3 class="text-lg font-semibold border-b border-slate-700 pb-2 cursor-help"
            title="Controls for the decode phase: how the model samples tokens and how many it is allowed to generate.">Outputs
            (Decode Stage)</h3>
          <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <label class="flex items-center gap-3 cursor-pointer"
              title="When supported, includes chain-of-thought or reasoning tokens in the streamed output. These extra tokens increase both latency and energy.">
              <input type="checkbox" id="includeThinking" class="w-5 h-5">
              <span class="text-sm font-medium">Include Thinking</span>
            </label>

            <div>
              <div class="flex justify-between mb-2">
                <label class="text-sm font-medium cursor-help"
                  title="Sampling randomness. Lower values are more deterministic; higher values increase variability and exploration but may waste energy on off-target tokens.">Temperature</label>
                <span id="tempValue" class="text-sm font-mono text-indigo-400">0.7</span>
              </div>
              <input type="range" id="temperature" min="0" max="1" step="0.1" value="0.7" class="w-full">
            </div>

            <div>
              <label class="block text-sm font-medium mb-2 cursor-help"
                title="Upper bound on completion length. Higher limits allow longer answers but also raise worst-case energy and latency.">Max
                Tokens</label>
              <input type="number" id="maxTokens" value="1000" class="w-full">
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Section: Response -->
    <div id="section-response" class="section-content">
      <div class="dashboard-card p-6">
        <h2 class="text-2xl font-bold flex items-center gap-2 mb-4">
          <span>üí¨</span> Response Output
        </h2>
        <div id="responseOutput"
          class="bg-slate-900 p-6 rounded-xl border border-slate-700 min-h-[200px] font-mono text-sm whitespace-pre-wrap">
          Run a test to see the model response here.
        </div>
      </div>

      <!-- Token Analysis (shown with Response) -->
      <div class="dashboard-card p-6">
        <h2 class="text-2xl font-bold flex items-center gap-2 mb-6">
          <span>üìä</span> Token Analysis
          <span class="text-xs text-slate-400 cursor-help"
            title="Breaks down total tokens into original input, hidden middleware overhead, optional thinking tokens, and final output to help interpret energy metrics.">‚ìò</span>
        </h2>

        <div style="height: 120px; position: relative; margin-bottom: 2rem;">
          <canvas id="tokenBreakdownChart"></canvas>
        </div>

        <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
          <div class="metric-card text-center" title="Total tokens in your explicit user and system prompts.">
            <div class="text-xs text-slate-400 mb-1">Input</div>
            <div id="inputTokensVal" class="metric-value">-</div>
          </div>
          <div class="metric-card text-center"
            title="Extra tokens added by middleware (system prompts, conversation context, injections, tools). These are invisible to the user but still consume energy.">
            <div class="text-xs text-slate-400 mb-1">Overhead</div>
            <div id="overheadTokensVal" class="metric-value"
              style="background: linear-gradient(135deg, #f59e0b, #d97706); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
              -</div>
          </div>
          <div class="metric-card text-center"
            title="Reasoning or chain-of-thought tokens when enabled. These improve interpretability but increase energy use.">
            <div class="text-xs text-slate-400 mb-1">Thinking</div>
            <div id="thinkingTokensVal" class="metric-value"
              style="background: linear-gradient(135deg, #a855f7, #9333ea); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
              -</div>
          </div>
          <div class="metric-card text-center"
            title="Visible answer tokens produced by the model. Energy-weighted metrics are usually normalised per 1k of these.">
            <div class="text-xs text-slate-400 mb-1">Output</div>
            <div id="outputTokensVal" class="metric-value"
              style="background: linear-gradient(135deg, #3b82f6, #2563eb); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
              -</div>
          </div>
        </div>

        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
          <div class="metric-card" title="Human-readable label for this test configuration (e.g. baseline vs injected prompt).">
            <div class="text-xs text-slate-400">Strategy</div>
            <div id="resultStrategy" class="font-medium truncate">-</div>
          </div>
          <div class="metric-card" title="Total tokens across prompt, overhead, thinking, and output.">
            <div class="text-xs text-slate-400">Total Tokens</div>
            <div id="resultTokens" class="font-medium">-</div>
          </div>
          <div class="metric-card" title="End-to-end time from request to last token.">
            <div class="text-xs text-slate-400">Latency</div>
            <div id="resultLatency" class="font-medium">-</div>
          </div>
          <div class="metric-card" title="Throughput of output tokens per second. Useful for comparing speed across models.">
            <div class="text-xs text-slate-400">Tokens/Sec</div>
            <div id="resultTokensPerSec" class="font-medium">-</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Section: Results -->
    <div id="section-results" class="section-content">
      <div class="space-y-6">

        <!-- Tests Overview (full width, first) -->
        <div class="dashboard-card p-6">
          <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl font-bold flex items-center gap-2">
              <span>üìà</span> Tests Overview
              <span class="text-xs text-slate-400 cursor-help"
                title="Session-level KPIs summarising energy (Wh), intensity per 1k tokens, speed, and carbon footprint derived from your selected grid.">‚ìò</span>
            </h2>
            <div class="flex items-center gap-4">
              <button onclick="clearAllResults()"
                class="text-xs text-slate-400 hover:text-red-400 px-2 py-1 rounded border border-slate-700 hover:border-red-400 transition-colors">Clear
                History</button>
            </div>
          </div>

          <!-- Top Row: Core KPIs (Clean & Focused) -->
          <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-6">
            <!-- Query Energy -->
            <div class="metric-card group relative overflow-hidden"
              title="Total measured or estimated watt-hours for this run or aggregated session.">
              <div class="absolute top-0 right-0 p-2 opacity-10 text-6xl">‚ö°</div>
              <div class="text-xs font-semibold text-slate-400 mb-1">Total Energy</div>
              <div class="metric-value text-3xl" id="kpiEnergyWh">-</div>
              <div class="text-[11px] text-slate-500 mt-1">Watt-hours per run</div>
            </div>

            <!-- Intensity -->
            <div class="metric-card group relative overflow-hidden"
              title="Energy-weighted token intensity (Wh per 1k tokens) using the selected normalisation.">
              <div class="absolute top-0 right-0 p-2 opacity-10 text-6xl">üéØ</div>
              <div class="text-xs font-semibold text-slate-400 mb-1">Intensity</div>
              <div class="metric-value text-3xl" id="kpiIntensityMain">-</div>
              <div class="text-[11px] text-slate-500 mt-1">Wh / 1k tokens</div>
            </div>

            <!-- Speed -->
            <div class="metric-card group relative overflow-hidden"
              title="Effective token throughput. Higher values generally mean faster, more efficient runs for similar energy.">
              <div class="absolute top-0 right-0 p-2 opacity-10 text-6xl">üöÄ</div>
              <div class="text-xs font-semibold text-slate-400 mb-1">Speed</div>
              <div class="metric-value text-3xl" id="kpiSpeedMain">-</div>
              <div class="text-[11px] text-slate-500 mt-1" id="kpiSpeedDetail">Total time (s)</div>
            </div>

            <!-- Carbon -->
            <div class="metric-card group relative overflow-hidden"
              title="Estimated carbon footprint for the run based on energy and your chosen electricity grid emission factor.">
              <div class="absolute top-0 right-0 p-2 opacity-10 text-6xl">üå±</div>
              <div class="text-xs font-semibold text-slate-400 mb-1">Carbon Footprint</div>
              <div class="metric-value text-3xl" id="kpiCarbonMain">-</div>
              <div class="text-[11px] text-slate-500 mt-1">gCO2 emissions</div>
            </div>
          </div>

          <!-- Chart Controls Toolbar -->
          <div class="flex flex-wrap items-center gap-4 mb-4 bg-slate-800/40 p-3 rounded-xl border border-slate-700/50">
            <div class="flex items-center gap-2 mr-4">
              <span class="text-xs font-bold text-slate-400 uppercase tracking-wider">Metric:</span>
              <div class="flex bg-slate-900 rounded-lg p-1">
                <button
                  class="px-3 py-1.5 text-xs font-medium rounded-md bg-indigo-600 text-white shadow-lg transition-all"
                  id="btnModeEnergy" onclick="setChartMode('energy')">Energy</button>
                <button
                  class="px-3 py-1.5 text-xs font-medium rounded-md text-slate-400 hover:text-white transition-all"
                  id="btnModeSpeed" onclick="setChartMode('speed')">Speed</button>
                <button
                  class="px-3 py-1.5 text-xs font-medium rounded-md text-slate-400 hover:text-white transition-all"
                  id="btnModeCarbon" onclick="setChartMode('carbon')">Carbon</button>
              </div>
            </div>

            <div class="h-6 w-px bg-slate-700"></div>

            <!-- Electricity Grid (only visible in Carbon mode) -->
            <div id="electricityGridContainer" class="flex items-center gap-2 hidden">
              <label class="text-xs font-semibold text-slate-400 cursor-help"
                title="Choose the electricity grid whose emission factor (kgCO2/kWh) should be used to convert Wh into gCO2.">Grid:</label>
              <select id="electricityGridSelect" onchange="updateCarbonCalculation()"
                class="text-xs py-1 pl-2 pr-6 bg-slate-900 border-slate-700 rounded-md">
                <option value="GLOBAL">Global Average (0.445 kgCO2/kWh)</option>
              </select>
            </div>

            <div class="flex items-center gap-4">
              <label
                class="flex items-center gap-2 text-xs cursor-pointer text-slate-300 hover:text-white transition-colors">
                <input type="checkbox" id="chartToggleRapl" checked onchange="updateMainChartVisibility()"
                  class="rounded border-slate-600 bg-slate-800 text-indigo-500 focus:ring-offset-slate-900">
                <span title="Toggle measured hardware energy series derived from RAPL.">Show RAPL (Actual)</span>
              </label>
              <label
                class="flex items-center gap-2 text-xs cursor-pointer text-slate-300 hover:text-white transition-colors">
                <input type="checkbox" id="chartToggleEst" checked onchange="updateMainChartVisibility()"
                  class="rounded border-slate-600 bg-slate-800 text-indigo-500 focus:ring-offset-slate-900">
                <span title="Toggle benchmark-based energy estimates (HF / Jegham / custom benchmarks).">Show
                  Estimates</span>
              </label>
            </div>

            <div class="h-6 w-px bg-slate-700"></div>

            <div class="flex items-center gap-2">
              <span class="text-xs font-bold text-slate-400 cursor-help"
                title="Choose whether energy/intensity should be normalised per 1k input tokens, output tokens, or total tokens.">Norm:</span>
              <select id="chartNormSelect" onchange="updateMainChart()"
                class="text-xs py-1 pl-2 pr-6 bg-slate-900 border-slate-700 rounded-md">
                <option value="output">Per 1k Output Tokens</option>
                <option value="input">Per 1k Input Tokens</option>
                <option value="total">Per 1k Total Tokens</option>
              </select>
            </div>
          </div>

          <!-- Main Chart -->
          <div style="height: 350px; position: relative; width: 100%;">
            <canvas id="mainResultsChart"></canvas>
          </div>
        </div>

        <!-- Benchmark Estimation (moved under Results Overview) -->
        <div class="dashboard-card p-6">
          <h2 class="text-2xl font-bold flex items-center gap-2 mb-6">
            <span>üìê</span> Benchmark Estimation
            <span class="text-xs text-slate-400 cursor-help"
              title="Compare live runs against external energy benchmarks (Hugging Face, Jegham et al.) or your own calibrated/custom benchmarks.">‚ìò</span>
          </h2>

          <div style="height: 170px; position: relative; margin-bottom: 1.5rem;">
            <canvas id="hfBenchmarkChartCanvas"></canvas>
          </div>

          <div class="space-y-4">
            <div class="bg-indigo-900/30 border border-indigo-700/50 rounded-xl p-4 flex justify-between items-center"
              title="Shows the benchmark currently used to derive estimated Wh/1000 e-tokens for this session.">
              <div>
                <h4 class="text-sm font-bold mb-1">Current Benchmark</h4>
                <p id="currentBenchmarkInfo" class="text-xs text-indigo-300 font-mono">-</p>
              </div>
              <button id="benchmarkInfoBtn" class="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-700 rounded text-xs">View
                Details</button>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label class="block text-sm font-semibold mb-2 cursor-help"
                  title="Choose which external benchmark family to use (e.g. Hugging Face AI Energy Score or Jegham et al.).">Benchmark
                  Source</label>
                <select id="benchmarkSourceSelect" class="w-full">
                  <option>Loading sources...</option>
                </select>
              </div>
              <div>
                <label class="block text-sm font-semibold mb-2 cursor-help"
                  title="Specific model or configuration within the selected benchmark family that becomes your baseline energy profile.">Baseline
                  Benchmark</label>
                <div class="flex gap-2">
                  <select id="benchmarkSwitcher" class="flex-1">
                    <option>Loading benchmarks...</option>
                  </select>
                  <button id="switchBenchmarkBtn" class="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded" disabled>
                    Apply
                  </button>
                </div>
              </div>
            </div>

            <div>
              <label class="block text-sm font-semibold mb-2 cursor-help"
                title="Overlay multiple benchmark models to compare their e-token intensities against each other and your current runs.">Compare
                Model Benchmarks</label>
              <select id="hfBenchmarkMulti" multiple class="w-full h-24">
                <option>Loading model benchmarks...</option>
              </select>
            </div>

            <div class="border-t border-slate-700 pt-6 mt-4">
              <h4 class="text-sm font-bold mb-4">Add Custom Benchmark</h4>
              <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <input type="text" id="customBenchmarkName" placeholder="Name (e.g. RTX 3080)" class="w-full">
                <input type="number" id="customBenchmarkWattHours" step="0.01" placeholder="Wh/1k etokens-o"
                  class="w-full">
                <input type="text" id="customBenchmarkDesc" placeholder="Description" class="w-full">
                <button id="addCustomBenchmarkBtn"
                  class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded whitespace-nowrap">
                  Add
                </button>
              </div>
            </div>

            <div class="text-xs text-slate-400 mt-2">
              Uses the selected benchmark and external baselines to estimate Wh/1000 e-tokens for this run and session.
            </div>
          </div>
        </div>

        <!-- Live Power RAPL Results -->
        <div class="dashboard-card p-6 space-y-6">
          <h2 class="text-2xl font-bold flex items-center gap-2 mb-2">
            <span>‚ö°</span> Live Power RAPL Results
            <span class="text-xs text-slate-400 cursor-help"
              title="Live hardware measurements using CPU/DRAM RAPL counters. Prefill vs decode energy is split using start/split/end snapshots.">‚ìò</span>
          </h2>

          <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="metric-card">
              <h4 class="text-sm font-bold mb-4 flex items-center gap-2">
                <span>üîÑ</span> Batch Testing
                <span class="text-[10px] text-slate-400 cursor-help"
                  title="Run the same live measurement N times with current settings to study variability and stability of Wh/1000 e-tokens.">‚ìò</span>
              </h4>
              <label class="block text-xs text-slate-400 mb-2 cursor-help"
                title="How many back-to-back live runs to perform. Larger batches give better statistics but take longer.">Number
                of Runs</label>
              <input type="number" id="raplBatchRuns" value="1" min="1" max="100" class="w-full">
            </div>

            <div class="metric-card">
              <h4 class="text-sm font-bold mb-4 flex items-center gap-2">
                <span>üé≤</span> Reproducibility & Calibration
                <span class="text-[10px] text-slate-400 cursor-help"
                  title="Control randomness across runs and create calibrated benchmarks from repeated RAPL measurements.">‚ìò</span>
              </h4>
              <label class="block text-xs text-slate-400 mb-2 cursor-help"
                title="Optional random seed for the model. Setting this makes batches more comparable by reducing sampling variance.">Seed
                (Optional)</label>
              <input type="number" id="seedInput" placeholder="Random" class="w-full">

              <div class="mt-4 pt-4 border-t border-slate-700">
                <div class="flex items-center justify-between">
                  <div>
                    <label class="block text-xs text-slate-400 mb-1 cursor-help"
                      title="Summarises whether you have run a RAPL calibration to turn live measurements into a reusable energy benchmark for this hardware.">Calibration</label>
                    <p class="text-[10px] text-slate-500" id="raplCalibrationStatus">Not run yet.</p>
                  </div>
                  <button id="runRaplCalibration" class="text-xs bg-slate-700 hover:bg-slate-600 px-3 py-1.5 rounded">
                    Run Calibration
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Prefill / Decode / Total history chart (multi-run line plot) -->
          <div style="height: 180px; position: relative; margin-top: 1.5rem; margin-bottom: 1.5rem;">
            <canvas id="prefillDecodeChart"></canvas>
          </div>

          <div id="raplResultsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            <!-- RAPL results will be populated here as metric cards -->
          </div>
        </div>

      </div>
    </div>

    <!-- CLI Modal -->
    <div id="cliModal" class="fixed inset-0 hidden z-50">
      <div class="w-full h-full flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
        <div
          class="bg-slate-900 rounded-xl shadow-2xl w-full max-w-4xl border border-slate-700 flex flex-col max-h-[80vh]">
          <div class="flex items-center justify-between p-4 border-b border-slate-700">
            <h3 class="text-lg font-mono font-bold text-green-400 flex items-center gap-2">
              <span class="animate-pulse">_</span> Live Measurement Logs
            </h3>
            <button id="closeCliModalBtn" class="text-slate-400 hover:text-white">‚úï</button>
          </div>
          <div id="cliLog" class="p-4 overflow-auto font-mono text-xs text-slate-300 space-y-1 flex-1"></div>
        </div>
      </div>
    </div>

    <!-- Hidden elements for JS compatibility -->
    <div class="hidden">
      <div id="modificationImpact"></div>
      <div id="connectionStatus"></div>
      <div id="energyBenchmark"></div>
      <div id="injectionTokens"></div>
      <div id="toolTokens"></div>
      <div id="inputTokens"></div>
      <div id="outputTokens"></div>
      <div id="tokenAnalysisNotes"></div>
      <div id="prefillPer1kIn"></div>
      <div id="decodePer1kOut"></div>
      <div id="ewOutPer1k"></div>
      <div id="raplIntensity"></div>
      <div id="powerBaseline"></div>
      <div id="powerActive"></div>
      <div id="powerMeasured"></div>
      <div id="prefillEnergy"></div>
      <div id="decodeEnergy"></div>
      <div id="sessionEnergy"></div>
      <div id="sessionCarbon"></div>
      <div id="sessionIntensity"></div>
      <div id="sessionTokens"></div>
      <div id="sessionRaplEnergy"></div>
      <input type="number" id="raplCalibrationRuns" value="5" class="hidden">
      <input type="number" id="raplCalibrationWords" value="120" class="hidden">
      <input type="text" id="customBenchmarkSpecs" class="hidden">
    </div>

  </div>

  <script>
    // Section Navigation - Toggle multiple sections
    function toggleSection(sectionId) {
      const section = document.getElementById(`section-${sectionId}`);
      const button = document.querySelector(`[data-section="${sectionId}"]`);

      // Toggle section visibility
      section.classList.toggle('active');

      // Toggle button active state
      button.classList.toggle('active');
    }
  </script>
  <script>
    // DOM references
    const modelSelect = document.getElementById('modelSelect');

    const systemPromptSelect = document.getElementById('systemPromptSelect');
    const systemPromptText = document.getElementById('systemPromptText');
    const clearSystemPromptBtn = document.getElementById('clearSystemPromptBtn');
    const conversationContextText = document.getElementById('conversationContextText');
    const userPrompt = document.getElementById('userPrompt');
    const temperature = document.getElementById('temperature');
    const maxTokens = document.getElementById('maxTokens');
    const tempValue = document.getElementById('tempValue');
    const runTest = document.getElementById('runTest');
    const stopTest = document.getElementById('stopTest');
    const clearResults = document.getElementById('clearResults');
    const exportData = document.getElementById('exportData');
    const showLogs = document.getElementById('showLogs');
    const cliModal = document.getElementById('cliModal');
    const cliLog = document.getElementById('cliLog');
    const closeCliModalBtn = document.getElementById('closeCliModalBtn');
    let _genProgressEl = null;
    let _genTimer = null;
    let _genStartMs = 0;
    let _genSpinIdx = 0;

    // Benchmark controls
    const currentBenchmarkInfo = document.getElementById('currentBenchmarkInfo');
    const benchmarkInfoBtn = document.getElementById('benchmarkInfoBtn');
    const benchmarkSwitcher = document.getElementById('benchmarkSwitcher');
    const switchBenchmarkBtn = document.getElementById('switchBenchmarkBtn');
    const benchmarkSwitcherConfig = document.getElementById('benchmarkSwitcherConfig');
    const switchBenchmarkBtnConfig = document.getElementById('switchBenchmarkBtnConfig');
    const customBenchmarkName = document.getElementById('customBenchmarkName');
    const customBenchmarkWattHours = document.getElementById('customBenchmarkWattHours');
    const customBenchmarkDesc = document.getElementById('customBenchmarkDesc');
    const customBenchmarkSpecs = document.getElementById('customBenchmarkSpecs');
    const addCustomBenchmarkBtn = document.getElementById('addCustomBenchmarkBtn');
    const runRaplCalibration = document.getElementById('runRaplCalibration');
    const runRaplBatch = document.getElementById('runRaplBatch');
    const raplBatchTableBody = document.getElementById('raplBatchTableBody');

    // Token analysis elements
    const inputTokens = document.getElementById('inputTokens');
    const outputTokens = document.getElementById('outputTokens');
    const injectionTokens = document.getElementById('injectionTokens');
    const toolTokens = document.getElementById('toolTokens');
    const tokenAnalysisNotes = document.getElementById('tokenAnalysisNotes');

    // Results elements
    const sessionEnergy = document.getElementById('sessionEnergy');
    const sessionCarbon = document.getElementById('sessionCarbon');
    const sessionIntensity = document.getElementById('sessionIntensity');
    const sessionTokens = document.getElementById('sessionTokens');
    const sessionRaplEnergy = document.getElementById('sessionRaplEnergy');

    const testEnergy = document.getElementById('testEnergy');
    const testEnergyBar = document.getElementById('testEnergyBar');
    const carbonImpact = document.getElementById('carbonImpact');
    const raplEnergy = document.getElementById('raplEnergy');
    const raplIntensity = document.getElementById('raplIntensity');

    const resultStrategy = document.getElementById('resultStrategy');
    const resultTokens = document.getElementById('resultTokens');
    const resultLatency = document.getElementById('resultLatency');
    const resultTokensPerSec = document.getElementById('resultTokensPerSec');

    // Results Overview KPI elements
    const kpiEnergyWh = document.getElementById('kpiEnergyWh');
    const kpiCarbonMain = document.getElementById('kpiCarbonMain');
    const kpiIntensityMain = document.getElementById('kpiIntensityMain');
    const kpiSpeedMain = document.getElementById('kpiSpeedMain');
    const kpiSpeedDetail = document.getElementById('kpiSpeedDetail');

    // Legacy / Details elements
    const kpiCarbonG = document.getElementById('kpiCarbonG'); // kept for legacy reference
    const kpiEffBenchmark = document.getElementById('kpiEffBenchmark');
    const kpiEffEllm = document.getElementById('kpiEffEllm');
    const kpiEffMeff = document.getElementById('kpiEffMeff');
    const kpiLatency = document.getElementById('kpiLatency');
    const kpiTokensPerSec = document.getElementById('kpiTokensPerSec');
    const kpiTtft = document.getElementById('kpiTtft');

    // Legacy efficiency score element (may not exist in DOM)
    const efficiencyScore = document.getElementById('efficiencyScore');

    const modificationImpact = document.getElementById('modificationImpact');
    const responseOutput = document.getElementById('responseOutput');
    const connectionStatus = document.getElementById('connectionStatus');

    const benchmarkSourceSelect = document.getElementById('benchmarkSourceSelect');
    const hfBenchmarkMulti = document.getElementById('hfBenchmarkMulti');
    let hfBenchmarksData = null;
    let benchmarkSourcesData = {};

    // State
    let ws = null;
    let energyHistory = [];
    let currentTestResults = null;
    let batchRunning = false;
    let batchStopRequested = false;
    let _raplBatchFirstDuration = null;
    let _raplLastBatchResult = null;
    let raplBatchSummaries = [];
    let systemPrompts = [];
    let inThinking = false;
    let answerStarted = false;
    let modelProvider = 'local'; // 'local' (Ollama) or 'cloud' (Groq)

    // Provider select element
    const modelProviderSelect = document.getElementById('modelProviderSelect');
    const cloudProviderNote = document.getElementById('cloudProviderNote');

    function renderRaplBatchTable() {
      const container = document.getElementById('raplResultsContainer');
      if (!container) return;

      container.innerHTML = '';

      if (raplBatchSummaries.length === 0) {
        container.innerHTML = `
          <div class="col-span-full text-center text-slate-400 py-8">
            <div class="text-4xl mb-2">üìä</div>
            <div>No RAPL measurements yet. Run a test with Live Power enabled.</div>
          </div>
        `;
        return;
      }

      const sorted = raplBatchSummaries.slice().reverse();
      sorted.forEach(s => {
        const card = document.createElement('div');
        card.className = 'metric-card';

        const meanIn = (typeof s.meanInputTokens === 'number') ? s.meanInputTokens : null;
        const meanOut = (typeof s.meanOutputTokens === 'number') ? s.meanOutputTokens : null;
        let ratioDisplay = 'n/a';
        if (meanIn != null && meanOut != null && meanOut > 0) {
          const ratio = meanIn / meanOut;
          ratioDisplay = `${meanIn.toFixed(0)} in / ${meanOut.toFixed(0)} out (ratio ${ratio.toFixed(2)} : 1)`;
        } else if (meanIn != null || meanOut != null) {
          ratioDisplay = `${meanIn != null ? meanIn.toFixed(0) : 'n/a'} in / ${meanOut != null ? meanOut.toFixed(0) : 'n/a'} out`;
        }

        const prefillWh = (typeof s.meanPrefillWh === 'number') ? s.meanPrefillWh : null;
        const decodeWh = (typeof s.meanDecodeWh === 'number') ? s.meanDecodeWh : null;
        const prefillWhText = prefillWh != null ? `${prefillWh.toFixed(6)} Wh` : 'n/a';
        const decodeWhText = decodeWh != null ? `${decodeWh.toFixed(6)} Wh` : 'n/a';

        card.innerHTML = `
          <div class="flex justify-between items-start mb-3">
            <div class="text-xs text-slate-400">${s.time}</div>
            <button data-id="${s.id}" class="text-red-400 hover:text-red-300 text-xs">‚úï</button>
          </div>
          <div class="space-y-2">
            <div>
              <div class="text-xs text-slate-500">Runs</div>
              <div class="text-lg font-bold">${s.runs}</div>
            </div>
            <div>
              <div class="text-xs text-slate-500">Mean Wh/1k e-tokens</div>
              <div class="text-2xl font-bold bg-gradient-to-r from-indigo-400 to-purple-400 bg-clip-text text-transparent">
                ${(s.meanWhPer1k ?? 0).toFixed(3)}
              </div>
            </div>
            <div class="grid grid-cols-2 gap-2 text-xs">
              <div>
                <div class="text-slate-500">Median</div>
                <div class="font-semibold">${(s.medianWhPer1k ?? 0).toFixed(3)}</div>
              </div>
              <div>
                <div class="text-slate-500">Std Dev</div>
                <div class="font-semibold">${(s.stdWhPer1k ?? 0).toFixed(3)}</div>
              </div>
              <div>
                <div class="text-slate-500">CV</div>
                <div class="font-semibold">${(s.cv ?? 0).toFixed(3)}</div>
              </div>
              <div>
                <div class="text-slate-500">Total Wh</div>
                <div class="font-semibold">${(s.meanTotalWh != null ? s.meanTotalWh.toFixed(6) : 'n/a')}</div>
              </div>
            </div>
            <div class="grid grid-cols-1 gap-1 text-xs mt-2">
              <div>
                <div class="text-slate-500">Input / Output Tokens (Œº)</div>
                <div class="font-semibold">${ratioDisplay}</div>
              </div>
              <div class="grid grid-cols-2 gap-2 mt-1">
                <div>
                  <div class="text-slate-500">Prefill Energy</div>
                  <div class="font-semibold">${prefillWhText}</div>
                </div>
                <div>
                  <div class="text-slate-500">Decode Energy</div>
                  <div class="font-semibold">${decodeWhText}</div>
                </div>
              </div>
            </div>
          </div>
        `;
        container.appendChild(card);
      });

      // Re-attach listeners
      container.querySelectorAll('button[data-id]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const id = e.target.getAttribute('data-id');
          raplBatchSummaries = raplBatchSummaries.filter(x => x.id !== id);
          renderRaplBatchTable();
        });
      });
    }

    // Chart State
    let mainResultsChart = null; // Replaces energyChart
    let currentChartMode = 'energy'; // 'energy', 'speed', 'carbon'
    // energyHistory is defined in State block above
    let prefillDecodeChart = null;
    let phaseEnergyChart = null;
    let hfBenchmarkChart = null;

    // Initialize (called at bottom)

    async function loadModels() {
      console.log('üîÑ Attempting to load models (provider=' + modelProvider + ')...');
      try {
        const r = await fetch('/api/models?provider=' + encodeURIComponent(modelProvider));
        console.log('üì° Models API response status:', r.status);
        if (!r.ok) {
          const errorText = await r.text();
          console.error('‚ùå Models API request failed:', r.status, errorText);
          modelSelect.innerHTML = '<option>Error loading models (API failed)</option>';
          return;
        }
        const d = await r.json();
        console.log('‚úì Models API response data:', d);

        // Check for cloud provider error (API key not configured)
        if (d.error && modelProvider === 'cloud') {
          modelSelect.innerHTML = '<option>‚ö†Ô∏è ' + d.error + '</option>';
          console.warn('‚ö†Ô∏è Cloud provider error:', d.error);
          return;
        }

        modelSelect.innerHTML = '';
        if (d.models && d.models.length > 0) {
          d.models.forEach(model => {
            const opt = document.createElement('option');
            opt.value = model;
            opt.textContent = model;
            modelSelect.appendChild(opt);
          });
          console.log('‚úì Models dropdown populated with', d.models.length, 'models');
          const preferred = (d.current && (d.current.instruct || d.current.base)) || null;
          if (preferred && d.models.includes(preferred)) {
            modelSelect.value = preferred;
          } else if (modelSelect.options.length > 0) {
            modelSelect.selectedIndex = 0;
          }
          // Load info for the selected model (only for local)
          if (modelProvider === 'local') {
            await loadModelInfo(modelSelect.value);
          } else {
            // Hide context info for cloud models
            document.getElementById('modelInfo').classList.add('hidden');
          }
        } else {
          const noModelsText = modelProvider === 'cloud'
            ? 'No Groq models available'
            : 'No models available';
          modelSelect.innerHTML = '<option>' + noModelsText + '</option>';
          console.log('‚ö†Ô∏è No models found in API response');
        }
      } catch (e) {
        console.error('‚ùå Failed to load models (JS error):', e);
        modelSelect.innerHTML = '<option>Error loading models (JS error)</option>';
      }
    }

    async function loadModelInfo(modelName) {
      if (!modelName || modelName.includes('Loading') || modelName.includes('Error') || modelName.includes('No models')) {
        document.getElementById('modelInfo').classList.add('hidden');
        return;
      }

      try {
        const r = await fetch(`/api/model-info/${encodeURIComponent(modelName)}`);
        if (r.ok) {
          const info = await r.json();
          const contextLength = info.context_length || 4096;
          document.getElementById('modelContextLength').textContent = contextLength.toLocaleString();
          document.getElementById('modelInfo').classList.remove('hidden');
          console.log(`‚úì Model ${modelName} context length: ${contextLength}`);
        } else {
          document.getElementById('modelInfo').classList.add('hidden');
          console.warn(`‚ö†Ô∏è Could not fetch info for model ${modelName}`);
        }
      } catch (e) {
        console.error(`‚ùå Error fetching model info for ${modelName}:`, e);
        document.getElementById('modelInfo').classList.add('hidden');
      }
    }

    // Update model info when model selection changes
    modelSelect.addEventListener('change', () => {
      if (modelProvider === 'local') {
        loadModelInfo(modelSelect.value);
      }
    });

    // Handle provider change (Local/Cloud)
    if (modelProviderSelect) {
      modelProviderSelect.addEventListener('change', async () => {
        modelProvider = modelProviderSelect.value;
        console.log('üîÑ Provider changed to:', modelProvider);

        // Update UI for cloud provider
        if (modelProvider === 'cloud') {
          // Disable and uncheck RAPL checkbox for cloud
          if (enableLivePower) {
            enableLivePower.checked = false;
            enableLivePower.disabled = true;
          }
          // Show cloud note
          if (cloudProviderNote) {
            cloudProviderNote.classList.remove('hidden');
          }
        } else {
          // Re-enable RAPL for local
          if (enableLivePower) {
            enableLivePower.disabled = false;
          }
          // Hide cloud note
          if (cloudProviderNote) {
            cloudProviderNote.classList.add('hidden');
          }
        }

        // Reload models for the new provider
        await loadModels();
      });
    }

    async function loadSystemPrompts() {
      try {
        const r = await fetch('/api/system-prompts');
        const d = await r.json();
        systemPrompts = Array.isArray(d.prompts) ? d.prompts : [];

        // Reset dropdown, keep the custom/empty option
        systemPromptSelect.innerHTML = '<option value="">Custom / empty</option>';

        systemPrompts.forEach(prompt => {
          const opt = document.createElement('option');
          opt.value = prompt.id;
          opt.textContent = prompt.name;
          systemPromptSelect.appendChild(opt);
        });
      } catch (e) {
        console.error('Failed to load system prompts:', e);
      }
    }

    // Emissions data for electricity grid carbon calculations
    let emissionsData = [];
    let currentEmissionFactor = 0.445; // Default: Global Average (IEA)

    async function loadEmissionsData() {
      try {
        const r = await fetch('/api/emissions');
        const d = await r.json();
        emissionsData = Array.isArray(d.emissions) ? d.emissions : [];

        const select = document.getElementById('electricityGridSelect');
        if (!select) return;

        select.innerHTML = '';

        emissionsData.forEach(entry => {
          const opt = document.createElement('option');
          opt.value = entry.country_code;
          opt.dataset.factor = entry.emission_factor;
          const factorDisplay = entry.emission_factor > 0 ? entry.emission_factor.toFixed(3) : '0.000';
          opt.textContent = `${entry.country_name} (${factorDisplay} kgCO2/kWh)`;
          select.appendChild(opt);
        });

        // Default to Global Average (first entry)
        if (select.options.length > 0) {
          select.selectedIndex = 0;
          currentEmissionFactor = parseFloat(select.options[0].dataset.factor) || 0.445;
        }

        console.log(`‚úì Loaded ${emissionsData.length} emission factors`);
      } catch (e) {
        console.error('Failed to load emissions data:', e);
      }
    }

    function getSelectedEmissionFactor() {
      const select = document.getElementById('electricityGridSelect');
      if (!select || !select.selectedOptions[0]) return 0.445;
      return parseFloat(select.selectedOptions[0].dataset.factor) || 0.445;
    }

    function updateCarbonCalculation() {
      currentEmissionFactor = getSelectedEmissionFactor();

      // Recalculate carbon for the current test results if available, preferring RAPL energy when present
      if (currentTestResults && currentTestResults.energy_metrics) {
        const em = currentTestResults.energy_metrics || {};
        const lpm = currentTestResults.live_power_metrics || {};
        let energyWh = 0;
        if (lpm && typeof lpm.total_wh === 'number') {
          energyWh = lpm.total_wh;
        } else if (typeof em.watt_hours_consumed === 'number') {
          energyWh = em.watt_hours_consumed;
        }
        const newCarbon = energyWh * currentEmissionFactor;

        if (kpiCarbonMain) {
          kpiCarbonMain.textContent = `${newCarbon.toFixed(4)} gCO2`;
        }
      }

      // Redraw chart to reflect new carbon values
      if (currentChartMode === 'carbon') {
        updateMainChart();
      }

      console.log(`Updated emission factor to ${currentEmissionFactor} kgCO2/kWh`);
    }

    // System prompt selection wiring
    if (systemPromptSelect) {
      systemPromptSelect.addEventListener('change', () => {
        const id = systemPromptSelect.value;
        if (!id) {
          // Custom / empty
          systemPromptText.value = '';
          return;
        }
        if (!Array.isArray(systemPrompts) || !systemPrompts.length) return;
        const sel = systemPrompts.find(p => p.id === id);
        if (sel) {
          systemPromptText.value = sel.content || '';
        }
      });
    }

    if (clearSystemPromptBtn) {
      clearSystemPromptBtn.addEventListener('click', () => {
        if (systemPromptSelect) systemPromptSelect.value = '';
        if (systemPromptText) systemPromptText.value = '';
      });
    }

    async function loadBenchmarks() {
      console.log('üîÑ Attempting to load benchmarks...');
      try {
        const r = await fetch('/api/energy-benchmarks');
        if (!r.ok) throw new Error(`API Error: ${r.status}`);

        const d = await r.json();
        console.log('‚úì Benchmarks loaded:', d);

        // Handle both array format and object with benchmarks property
        const benchmarks = Array.isArray(d) ? d : (d.benchmarks || []);

        // Filter benchmarks by currently selected external source, but always
        // keep lab-calibrated/custom entries that have no matching external source.
        const sourceId = getSelectedBenchmarkSourceId();
        const filtered = benchmarks.filter(b => {
          if (!sourceId) return true;
          if (!b.source) return true;
          return b.source === sourceId;
        });

        const selects = [benchmarkSwitcher].filter(Boolean);
        selects.forEach(sel => {
          sel.innerHTML = '';
          filtered.forEach(b => {
            const opt = document.createElement('option');
            opt.value = b.name;
            const fullId = b.name;
            const shortId = typeof fullId === 'string' ? fullId.split('/').pop() : String(fullId);
            const whVal = b.wh_per_1000_tokens || b.watt_hours_per_1000_tokens;
            opt.textContent = `${shortId} (${whVal} Wh/1k)`;
            opt.dataset.desc = b.description || '';
            opt.dataset.wh = whVal;
            sel.appendChild(opt);
          });
        });

        // Set initial info
        updateBenchmarkInfo();
      } catch (e) {
        console.error('‚ùå Failed to load benchmarks:', e);
        if (benchmarkSwitcher) benchmarkSwitcher.innerHTML = '<option>Error loading benchmarks</option>';
      }
    }

    function updateBenchmarkInfo() {
      if (!benchmarkSwitcher || !currentBenchmarkInfo) return;
      const selected = benchmarkSwitcher.options[benchmarkSwitcher.selectedIndex];
      if (selected) {
        const fullId = selected.value;
        const shortId = typeof fullId === 'string' ? fullId.split('/').pop() : String(fullId);
        currentBenchmarkInfo.textContent = `${shortId}: ${selected.dataset.desc || ''}`;
      }

      // Mirror selection into config select
      if (benchmarkSwitcherConfig) {
        benchmarkSwitcherConfig.value = benchmarkSwitcher.value;
      }
    }

    // Event Listeners for Benchmark Switching
    function attachSwitchVisualFeedback(btn) {
      if (!btn) return;
      btn.addEventListener('click', () => {
        updateBenchmarkInfo();
        const originalText = btn.textContent;
        btn.textContent = 'Applied!';
        btn.classList.add('bg-green-600');
        setTimeout(() => {
          btn.textContent = originalText;
          btn.classList.remove('bg-green-600');
        }, 1000);
      });
    }

    attachSwitchVisualFeedback(switchBenchmarkBtn);
    attachSwitchVisualFeedback(switchBenchmarkBtnConfig);

    if (benchmarkSwitcher) {
      benchmarkSwitcher.addEventListener('change', () => {
        if (switchBenchmarkBtn) switchBenchmarkBtn.disabled = false;
        if (benchmarkSwitcherConfig) benchmarkSwitcherConfig.value = benchmarkSwitcher.value;
        // When the baseline benchmark selection changes, refresh info and charts
        updateBenchmarkInfo();
        updateMainChart();
        if (currentTestResults) {
          updateHfBenchmarkChartForRun(currentTestResults);
        }
      });
    }

    if (benchmarkSwitcherConfig) {
      benchmarkSwitcherConfig.addEventListener('change', () => {
        if (benchmarkSwitcher) {
          benchmarkSwitcher.value = benchmarkSwitcherConfig.value;
          updateBenchmarkInfo();
        }
        if (switchBenchmarkBtnConfig) switchBenchmarkBtnConfig.disabled = false;
      });
    }

    function getSelectedBenchmarkSourceId() {
      if (benchmarkSourceSelect && benchmarkSourceSelect.value) return benchmarkSourceSelect.value;
      const keys = Object.keys(benchmarkSourcesData || {});
      if (!keys.length) return null;
      const jeghamKey = keys.find(k => typeof k === 'string' && k.toLowerCase().includes('jegham'));
      if (jeghamKey) return jeghamKey;
      const hfKey = keys.find(k => typeof k === 'string' && k.toLowerCase().includes('hugging'));
      return hfKey || keys[0];
    }

    function getModelsForSelectedSource() {
      const sourceId = getSelectedBenchmarkSourceId();
      if (sourceId && benchmarkSourcesData && benchmarkSourcesData[sourceId] && Array.isArray(benchmarkSourcesData[sourceId].models)) {
        return benchmarkSourcesData[sourceId].models;
      }
      if (hfBenchmarksData && Array.isArray(hfBenchmarksData.models)) {
        return hfBenchmarksData.models;
      }
      return [];
    }

    function populateBenchmarkSourceSelect() {
      if (!benchmarkSourceSelect || !benchmarkSourcesData) return;
      const entries = Object.values(benchmarkSourcesData);
      if (!entries.length) return;
      benchmarkSourceSelect.innerHTML = '';
      entries.forEach(src => {
        const opt = document.createElement('option');
        opt.value = src.data_source;
        opt.textContent = src.data_source;
        benchmarkSourceSelect.appendChild(opt);
      });
      // Default to Hugging Face if available, otherwise first source
      const keys = Object.keys(benchmarkSourcesData || {});
      if (keys.length) {
        const jeghamKey = keys.find(k => typeof k === 'string' && k.toLowerCase().includes('jegham'));
        const hfKey = keys.find(k => typeof k === 'string' && k.toLowerCase().includes('hugging'));
        const defaultId = jeghamKey || hfKey || keys[0];
        benchmarkSourceSelect.value = defaultId;
      }
    }

    function populateHfBenchmarksSelect() {
      if (!hfBenchmarkMulti) return;
      const models = getModelsForSelectedSource();
      if (!Array.isArray(models) || models.length === 0) return;
      hfBenchmarkMulti.innerHTML = '';
      models.forEach(m => {
        const opt = document.createElement('option');
        const fullId = m.model_id;
        const shortId = typeof fullId === 'string' ? fullId.split('/').pop() : String(fullId);
        opt.value = fullId;
        const whIn = (typeof m.wh_per_1000_input_etokens === 'number')
          ? m.wh_per_1000_input_etokens.toFixed(4)
          : 'n/a';
        const whOut = (typeof m.wh_per_1000_output_etokens === 'number')
          ? m.wh_per_1000_output_etokens.toFixed(4)
          : whIn;
        opt.textContent = `${shortId} (Wh/1k etokens-i: ${whIn}, Wh/1k etokens-o: ${whOut})`;
        hfBenchmarkMulti.appendChild(opt);
      });
    }

    if (benchmarkSourceSelect) {
      benchmarkSourceSelect.addEventListener('change', () => {
        // Refresh both the compare-model list and the baseline benchmark list
        populateHfBenchmarksSelect();
        loadBenchmarks();
      });
    }

    if (hfBenchmarkMulti) {
      hfBenchmarkMulti.addEventListener('change', () => {
        if (currentTestResults) {
          updateHfBenchmarkChartForRun(currentTestResults);
        }
      });
    }

    async function loadHfBenchmarks() {
      try {
        const r = await fetch('/api/benchmark-info');
        if (!r.ok) return;
        const d = await r.json();
        hfBenchmarksData = d.hf_benchmarks || null;
        benchmarkSourcesData = d.benchmark_sources || {};
        populateBenchmarkSourceSelect();
        populateHfBenchmarksSelect();
      } catch (e) {
        console.error('Failed to load Hugging Face / external benchmarks:', e);
      }
    }

    function updateHfBenchmarkChartForRun(data) {
      if (!hfBenchmarkChart) return;
      const models = getModelsForSelectedSource();
      if (!Array.isArray(models) || models.length === 0) return;

      const bm = data.basic_metrics || {};
      const promptTokens = typeof bm.prompt_tokens === 'number' ? bm.prompt_tokens : 0;
      const completionTokens = typeof bm.completion_tokens === 'number' ? bm.completion_tokens : 0;

      if (promptTokens <= 0 && completionTokens <= 0) return;

      const selectedIds = hfBenchmarkMulti
        ? Array.from(hfBenchmarkMulti.selectedOptions).map(o => o.value)
        : [];

      const chosen = selectedIds.length > 0
        ? models.filter(m => selectedIds.includes(m.model_id))
        : models.slice(0, 5);

      const labels = [];
      const values = [];

      const inK = promptTokens / 1000.0;
      const outK = completionTokens / 1000.0;

      // 1. Baseline (Selected Benchmark)
      // Recalculate using the CURRENT selected benchmark specs, not just the one in 'data'
      // to allow switching to update the comparison.
      let baselineWh = 0;
      const benchOpt = benchmarkSwitcher.selectedOptions[0];
      if (benchOpt) {
        const benchWh = parseFloat(benchOpt.dataset.wh) || 0;
        // Simple assumption: Benchmark is uniform input/output unless we have detailed specs
        // We'll use the generic wh/1k for both.
        baselineWh = (inK + outK) * benchWh;
        // Note: If we had separate input/output specs for the *benchmark* itself, we'd use them.
        // But currently the UI only has a single scalar for custom/loaded benchmarks usually.

        labels.push(`Baseline (${benchOpt.text.split(' ')[0]})`);
        values.push(baselineWh);
      } else if (typeof data.energy_metrics?.watt_hours_consumed === 'number') {
        // Fallback to actual if no benchmark selected (shouldn't happen)
        labels.push('Actual (this host)');
        values.push(data.energy_metrics.watt_hours_consumed);
      }

      chosen.forEach(m => {
        const whPer1kIn = typeof m.wh_per_1000_input_etokens === 'number' ? m.wh_per_1000_input_etokens : null;
        // If output specific is missing, fallback to input or generic
        const whPer1kOut = typeof m.wh_per_1000_output_etokens === 'number' ? m.wh_per_1000_output_etokens : whPer1kIn;

        if (whPer1kIn == null) return;

        const estimatedWh = (inK * whPer1kIn) + (outK * (whPer1kOut || whPer1kIn));

        const fullId = m.model_id;
        const shortId = typeof fullId === 'string' ? fullId.split('/').pop() : String(fullId);
        labels.push(shortId);
        values.push(estimatedWh);
      });

      hfBenchmarkChart.data.labels = labels;
      hfBenchmarkChart.data.datasets[0].data = values;
      hfBenchmarkChart.update();
    }

    async function switchBenchmark() {
      const selectedBenchmark = benchmarkSwitcher.value;
      if (!selectedBenchmark) {
        alert('Please select a benchmark');
        return;
      }

      try {
        switchBenchmarkBtn.disabled = true;
        switchBenchmarkBtn.textContent = 'Recalculating...';

        const r = await fetch('/api/switch-benchmark', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ benchmark_name: selectedBenchmark })
        });

        if (r.ok) {
          const result = await r.json();
          // Update the UI with recalculated values
          updateSessionWithRecalculatedData(result);
          // Success - no alert, just log and update UI
          console.log(`‚úì Switched to ${result.benchmark_used} benchmark`);
          // Update benchmark info display silently
          updateBenchmarkInfo();
        } else {
          const error = await r.json();
          alert(`Error switching benchmark: ${error.detail || 'Unknown error'}`);
        }
      } catch (e) {
        console.error('Failed to switch benchmark:', e);
        alert('Error switching benchmark');
      } finally {
        switchBenchmarkBtn.disabled = false;
        switchBenchmarkBtn.textContent = 'Recalculate with Selected Benchmark';
      }
    }

    async function addCustomBenchmark() {
      const name = customBenchmarkName.value.trim();
      const wattHours = parseFloat(customBenchmarkWattHours.value);
      const desc = customBenchmarkDesc.value.trim();
      const specs = customBenchmarkSpecs.value.trim();

      if (!name || !desc || isNaN(wattHours) || wattHours <= 0) {
        alert('Please fill in all required fields with valid values');
        return;
      }

      try {
        addCustomBenchmarkBtn.disabled = true;
        addCustomBenchmarkBtn.textContent = 'Adding...';

        const r = await fetch('/api/add-custom-benchmark', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: name,
            description: desc,
            watt_hours_per_1000_tokens: wattHours,
            hardware_specs: specs || undefined
          })
        });

        if (r.ok) {
          const result = await r.json();
          alert(result.message);

          // Clear form and reload benchmark options
          customBenchmarkName.value = '';
          customBenchmarkWattHours.value = '';
          customBenchmarkDesc.value = '';
          customBenchmarkSpecs.value = '';

          await loadBenchmarks();
          await loadBenchmarks(); // Refresh benchmarks
          benchmarkSwitcher.value = name; // Select the new benchmark
          updateBenchmarkInfo();
        } else {
          const error = await r.json();
          alert(`Error adding benchmark: ${error.detail || 'Unknown error'}`);
        }
      } catch (e) {
        console.error('Failed to add custom benchmark:', e);
        alert('Error adding custom benchmark');
      } finally {
        addCustomBenchmarkBtn.disabled = false;
        addCustomBenchmarkBtn.textContent = 'Add Custom Benchmark';
      }
    }

    async function runRaplCalibrationHandler() {
      // Block RAPL calibration for cloud providers
      if (modelProvider === 'cloud') {
        alert('RAPL calibration is only available for local (Ollama) models. Please switch to Local provider.');
        return;
      }

      const runsInput = document.getElementById('raplCalibrationRuns');
      const statusEl = document.getElementById('raplCalibrationStatus');
      const statsContainer = document.getElementById('raplCalibrationStats');
      const runs = parseInt(runsInput.value, 10) || 1;
      const targetWordsInput = document.getElementById('raplCalibrationWords');
      const target_words = parseInt(targetWordsInput.value, 10) || 120;

      const model = modelSelect.value;
      const includeThinking = document.getElementById('includeThinking').checked;
      if (!model) {
        alert('Please select a model before running RAPL calibration.');
        return;
      }

      try {
        if (statusEl) statusEl.textContent = `Running ${runs} RAPL calibration run(s)‚Ä¶ this may take a while.`;
        runRaplCalibration.disabled = true;
        // Open CLI modal and log start
        if (cliModal && cliLog) {
          cliModal.classList.remove('hidden');
          cliLog.textContent += `\n[CALIBRATION] Starting ${runs} RAPL calibration run(s) for ${model}‚Ä¶`;
          cliLog.scrollTop = cliLog.scrollHeight;
        }

        const r = await fetch('/api/rapl-calibrate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ runs, model_name: model, include_thinking: includeThinking, target_words })
        });

        if (!r.ok) {
          const err = await r.json().catch(() => ({}));
          throw new Error(err.detail || 'Calibration failed');
        }

        const data = await r.json();
        const s = data.stats || {};
        const b = data.benchmark || {};

        const meanEl = document.getElementById('raplCalMean');
        const medEl = document.getElementById('raplCalMedian');
        const stdEl = document.getElementById('raplCalStd');
        const p5El = document.getElementById('raplCalP5');
        const p95El = document.getElementById('raplCalP95');
        const cvEl = document.getElementById('raplCalCv');
        const nameEl = document.getElementById('raplCalBenchmarkName');

        if (meanEl) meanEl.textContent = (s.mean ?? 0).toFixed(6);
        if (medEl) medEl.textContent = (s.median ?? 0).toFixed(6);
        if (stdEl) stdEl.textContent = (s.std ?? 0).toFixed(6);
        if (p5El) p5El.textContent = (s.p5 ?? 0).toFixed(6);
        if (p95El) p95El.textContent = (s.p95 ?? 0).toFixed(6);
        if (cvEl) cvEl.textContent = s.cv != null ? s.cv.toFixed(2) : '-';
        if (nameEl) nameEl.textContent = b.name || '-';

        if (statsContainer) statsContainer.classList.remove('hidden');
        if (statusEl) statusEl.textContent = `RAPL calibration complete. Benchmark '${b.name || ''}' is now available.`;

        if (cliLog) {
          cliLog.textContent += `\n[CALIBRATION] Complete. Benchmark '${b.name || ''}' median=${(s.median ?? 0).toFixed(6)} Wh/1K.`;
          cliLog.scrollTop = cliLog.scrollHeight;
        }

        // Refresh benchmark lists and auto-select the new calibrated benchmark
        await loadBenchmarks();
        await loadBenchmarks();
        benchmarkSwitcher.value = b.name;
        updateBenchmarkInfo();
        if (energyBenchmark) energyBenchmark.value = b.name;
      } catch (e) {
        console.error('RAPL calibration failed:', e);
        if (statusEl) statusEl.textContent = 'RAPL calibration failed.';
        if (cliLog) {
          cliLog.textContent += `\n[CALIBRATION] Failed: ${e && e.message ? e.message : e}`;
          cliLog.scrollTop = cliLog.scrollHeight;
        }
      } finally {
        runRaplCalibration.disabled = false;
      }
    }

    // Build payload from current UI (system prompt + conversation context + query + injections + settings)
    function buildEnergyPayload(forceRapl = false) {
      const userQuery = userPrompt.value.trim();
      if (!userQuery) {
        throw new Error('Please enter a user query');
      }

      // Get raw components
      const baseSystem = systemPromptText.value.trim();
      const convoContext = conversationContextText ? conversationContextText.value.trim() : '';

      // Get structured injections
      const userInjections = getInjections().map(inj => ({
        description: inj.description,
        content: inj.content
      }));

      // Determine if RAPL should be enabled (always false for cloud)
      const isCloud = modelProvider === 'cloud';
      const enableRapl = isCloud ? false : (forceRapl ? true : (document.getElementById('enableLivePower')?.checked === true));

      const payload = {
        // New structured fields for backend composition
        system_prompt: baseSystem,
        user_prompt: userQuery,
        conversation_context: convoContext,
        injections: userInjections,

        // Legacy fields (optional, but good to keep for now)
        system: baseSystem,
        user: userQuery,

        model_name: modelSelect.value,
        strategy_name: 'custom_injection',
        energy_benchmark: benchmarkSwitcher.value || 'conservative_estimate',
        injection_type: userInjections.length > 0 ? 'user_defined' : 'none',

        temp: parseFloat(temperature.value),
        max_tokens: parseInt(maxTokens.value),
        seed: document.getElementById('seedInput').value ? parseInt(document.getElementById('seedInput').value) : null,
        enable_live_power_monitoring: enableRapl,
        include_thinking: (document.getElementById('includeThinking')?.checked === true),

        // Provider field for backend routing
        provider: modelProvider
      };

      return payload;
    }

    function updateSessionWithRecalculatedData(recalculatedData) {
      // Update session summary display
      if (sessionEnergy && typeof recalculatedData.total_energy_wh === 'number') {
        sessionEnergy.textContent = `${recalculatedData.total_energy_wh.toFixed(4)} Wh`;
      }
      if (sessionCarbon && typeof recalculatedData.total_carbon_gco2 === 'number') {
        sessionCarbon.textContent = `${recalculatedData.total_carbon_gco2.toFixed(2)} gCO2`;
      }
      if (sessionIntensity && typeof recalculatedData.average_energy_per_1000_tokens === 'number') {
        sessionIntensity.textContent = `${recalculatedData.average_energy_per_1000_tokens.toFixed(4)} Wh/1K`;
      }
      if (sessionTokens && typeof recalculatedData.total_tokens === 'number') {
        sessionTokens.textContent = recalculatedData.total_tokens;
      }
      if (sessionRaplEnergy && recalculatedData.session_summary?.rapl_session) {
        sessionRaplEnergy.textContent = `${recalculatedData.session_summary.rapl_session.toFixed(6)} Wh`;
      }

      // If we have current test results, update the energy display for the current test
      if (currentTestResults && recalculatedData && Array.isArray(recalculatedData.readings) && recalculatedData.readings.length > 0) {
        // Find the current test in the recalculated readings (last one)
        const currentTest = recalculatedData.readings[recalculatedData.readings.length - 1];
        if (currentTest) {
          const energy = currentTest.watt_hours_consumed;
          const carbon = currentTest.carbon_grams_co2;

          if (testEnergy && typeof energy === 'number') {
            testEnergy.textContent = `${energy.toFixed(4)} Wh`;
          }
          if (carbonImpact && typeof carbon === 'number') {
            carbonImpact.textContent = `${carbon.toFixed(2)} gCO2`;
          }

          // Update main KPIs using a synthetic energy_metrics object
          const completionTokens = typeof currentTest.completion_tokens === 'number'
            ? currentTest.completion_tokens
            : (typeof currentTest.total_tokens === 'number' ? currentTest.total_tokens : 0);
          const effScore = completionTokens > 0
            ? (energy / (completionTokens / 1000))
            : 0;

          const syntheticEnergyMetrics = {
            benchmark_used: recalculatedData.benchmark_used,
            watt_hours_consumed: energy,
            carbon_grams_co2: carbon,
            energy_efficiency_score: effScore
          };

          // Reuse existing per-run display logic
          updateEnergyDisplay(syntheticEnergyMetrics);

          // Explicitly update benchmark efficiency KPI (Wh/1K output tokens)
          if (kpiEffBenchmark) {
            kpiEffBenchmark.textContent = effScore > 0 ? `${effScore.toFixed(4)} Wh/1K` : '-';
          }

          // Update energy bar
          let energyLevel = 'low';
          let barWidth = Math.min(energy * 10, 100); // Scale for visualization

          if (energy > 0.5) energyLevel = 'medium';
          if (energy > 1.0) energyLevel = 'high';

          if (testEnergyBar) {
            testEnergyBar.style.width = `${barWidth}%`;
            testEnergyBar.className = `energy-bar energy-${energyLevel} h-4 rounded-full`;
          }
        }
      }
    }

    // ===== INJECTION MANAGEMENT =====
    let injectionCounter = 0;
    const injections = [];

    function addInjection(description = '', content = '') {
      const id = `injection_${injectionCounter++}`;
      const injection = { id, description, content };
      injections.push(injection);

      const injectionHTML = `
        <div class="border rounded p-3 bg-gray-50" id="${id}">
          <div class="flex justify-between items-start mb-2">
            <input type="text" class="flex-1 p-1 border rounded text-sm injection-desc" 
                   placeholder="Injection Type (e.g., system_prompt, tool_results, memory, cot)" 
                   value="${description}">
            <button class="ml-2 text-red-600 hover:text-red-800 text-sm remove-injection" data-id="${id}">‚úï</button>
          </div>
          <textarea class="w-full p-2 border rounded text-sm injection-content" 
                    placeholder="Enter injection content...">${content}</textarea>
        </div>
      `;

      document.getElementById('injectionsContainer').insertAdjacentHTML('beforeend', injectionHTML);

      // Add event listeners
      document.querySelector(`#${id} .remove-injection`).addEventListener('click', function () {
        removeInjection(id);
      });
    }

    function removeInjection(id) {
      const index = injections.findIndex(inj => inj.id === id);
      if (index > -1) injections.splice(index, 1);
      document.getElementById(id).remove();
    }

    function getInjections() {
      const result = [];
      document.querySelectorAll('#injectionsContainer > div').forEach(div => {
        const desc = div.querySelector('.injection-desc').value;
        const content = div.querySelector('.injection-content').value;
        if (content.trim()) {
          result.push({ description: desc || 'Unnamed', content: content.trim() });
        }
      });
      return result;
    }

    // Add event listener for add button
    document.getElementById('addInjectionBtn').addEventListener('click', () => addInjection());

    // Note: no default injections; system prompt is controlled by the fixed field above.

    // ===== RUN TEST (UPDATED FOR NEW INJECTION SYSTEM & BATCH TRIGGER) =====
    async function runEnergyTest() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        alert('WebSocket not connected. Please refresh the page.');
        return;
      }

      if (!modelSelect.value || /No models/i.test(modelSelect.value)) {
        alert('No valid model selected. Start Ollama and pick a model.');
        return;
      }

      // Check for Batch Mode
      const liveChecked = document.getElementById('enableLivePower')?.checked === true;
      const batchRuns = parseInt(document.getElementById('raplBatchRuns').value) || 1;

      if (liveChecked && batchRuns > 1) {
        // Trigger Batch Handler instead
        await runRaplBatchHandler();
        return;
      }

      responseOutput.textContent = '';
      currentTestResults = null;
      inThinking = false;
      answerStarted = false;
      stopGenerationProgress(true);
      if (cliLog) cliLog.innerHTML = '';

      if (liveChecked) openCliModal();

      let payload;
      try {
        payload = buildEnergyPayload(false);
      } catch (e) {
        alert(e.message);
        return;
      }

      // Brief CLI log to confirm injections
      const sysPreview = (payload.system || '').slice(0, 200).replace(/\n/g, ' ');
      appendCliLog(`üîß System prompt set (${payload.system?.length || 0} chars): ${sysPreview}${(payload.system && payload.system.length > 200) ? '‚Ä¶' : ''}`);
      appendCliLog(`üß© Injections meta: ${JSON.stringify(payload.injection_params?.metadata || {})}`);
      if (payload.seed) appendCliLog(`üé≤ Seed: ${payload.seed}`);

      console.log('üì§ Sending payload:', payload);

      ws.send(JSON.stringify(payload));
      runTest.disabled = true;
      runTest.innerHTML = '<span class="animate-spin mr-2">‚Üª</span> Running...';
      stopTest.disabled = false;
      stopTest.classList.remove('bg-gray-100', 'text-gray-400', 'cursor-not-allowed');
      stopTest.classList.add('btn-danger', 'hover:bg-red-700');
    }
    function stopEnergyTest() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        batchStopRequested = true;
        stopTest.disabled = true;
        stopTest.textContent = 'Stopping...';
        ws.send(JSON.stringify({ command: 'cancel' }));
      }
    }

    // Core UI event bindings (replacing legacy setupEventListeners)
    if (runTest) {
      runTest.addEventListener('click', () => {
        runEnergyTest();
      });
    }

    if (stopTest) {
      stopTest.addEventListener('click', () => {
        stopEnergyTest();
      });
    }

    if (clearResults) {
      clearResults.addEventListener('click', () => {
        clearAllResults();
      });
    }

    if (exportData) {
      exportData.addEventListener('click', () => {
        exportSessionData();
      });
    }

    if (showLogs) {
      showLogs.addEventListener('click', () => {
        openCliModal();
      });
    }

    if (closeCliModalBtn) {
      closeCliModalBtn.addEventListener('click', () => {
        closeCliModal();
      });
    }

    if (switchBenchmarkBtn) {
      switchBenchmarkBtn.addEventListener('click', () => {
        switchBenchmark();
      });
    }

    if (addCustomBenchmarkBtn) {
      addCustomBenchmarkBtn.addEventListener('click', () => {
        addCustomBenchmark();
      });
    }

    if (runRaplCalibration) {
      runRaplCalibration.addEventListener('click', () => {
        runRaplCalibrationHandler();
      });
    }

    if (benchmarkInfoBtn) {
      benchmarkInfoBtn.addEventListener('click', () => {
        if (currentBenchmarkInfo) {
          alert(currentBenchmarkInfo.textContent || 'No benchmark selected yet.');
        }
      });
    }

    if (injectConversationBtn) {
      injectConversationBtn.addEventListener('click', () => {
        // Find last interaction from energyHistory or UI logs?
        // Since we don't persist full conversation history in this simplified UI,
        // we'll try to grab the last available output content from the UI itself
        // or the last result.
        if (currentTestResults && currentTestResults.response) {
          const lastResp = currentTestResults.response;
          const userQ = currentTestResults.user_prompt || '';

          if (lastResp) {
            const existing = conversationContextText.value;
            const turn = `<user>${userQ}</user>\n<assistant>${lastResp}</assistant>\n`;
            conversationContextText.value = existing ? (existing + '\n' + turn) : turn;
            // Flash visual feedback
            injectConversationBtn.textContent = 'Injected!';
            setTimeout(() => injectConversationBtn.textContent = 'Inject Last Turn', 1000);
          } else {
            alert('No previous response available to inject.');
          }
        } else if (responseOutput && responseOutput.textContent && responseOutput.textContent.length > 10 && !responseOutput.textContent.includes('Run a test')) {
          // Fallback to scraping the div if no object
          const content = responseOutput.textContent;
          const existing = conversationContextText.value;
          const turn = `<assistant>${content}</assistant>\n`;
          conversationContextText.value = existing ? (existing + '\n' + turn) : turn;
          injectConversationBtn.textContent = 'Injected!';
          setTimeout(() => injectConversationBtn.textContent = 'Inject Last Turn', 1000);
        } else {
          alert('No recent output found to inject.');
        }
      });
    }

    async function handleTestCompletion(data) {
      runTest.disabled = false;
      runTest.textContent = 'Run Energy Test';
      stopTest.disabled = true;
      stopTest.textContent = 'Stop Test';

      if (data.error) {
        alert(`Test failed: ${data.error}`);
        return;
      }

      // In batch mode, just stash the latest result and let the batch handler
      // decide when to update the main UI (only once at the end).
      if (batchRunning) {
        _raplLastBatchResult = data;
      } else {
        currentTestResults = data;

        // Update energy display
        updateEnergyDisplay(data.energy_metrics);

        // Update results display
        updateResultsDisplay(data);

        // Update chart
        updateMainResultsChart(data);

        // Update session summary
        await updateSessionSummary();

        const usedBenchmark = data.energy_metrics.benchmark_used;
        if (usedBenchmark && benchmarkSwitcher && usedBenchmark !== benchmarkSwitcher.value) {
          // Refresh benchmarks to ensure we have the latest
          await loadBenchmarks();

          // Select the benchmark
          const opt = Array.from(benchmarkSwitcher.options).find(o => o.value === usedBenchmark);
          if (opt) {
            benchmarkSwitcher.value = usedBenchmark;
            updateBenchmarkInfo();
          }
        }

        // Analyze modification impact
        analyzeModificationImpact(data);

        // If this was a single RAPL-enabled run with a valid measurement, record it into the RAPL table
        if (!batchRunning && data.live_power_metrics && data.live_power_metrics.measured_wh_per_1000_tokens != null) {
          const now = new Date();
          const ts = now.toLocaleTimeString();
          const lpm = data.live_power_metrics || {};
          const raplWhPer1k = lpm.measured_wh_per_1000_tokens;
          const inTok = data.basic_metrics?.prompt_tokens ?? null;
          const outTok = data.basic_metrics?.completion_tokens ?? null;

          let prefillPer1k = null;
          if (lpm.calib_prefill_per_1000_input_tokens != null) {
            prefillPer1k = lpm.calib_prefill_per_1000_input_tokens;
          } else if (lpm.prefill_active_per_1000_input_tokens != null) {
            prefillPer1k = lpm.prefill_active_per_1000_input_tokens;
          } else if (lpm.prefill_wh_per_1000_input_tokens != null) {
            prefillPer1k = lpm.prefill_wh_per_1000_input_tokens;
          }

          let decodePer1k = null;
          if (lpm.calib_baseline_per_1000_output_tokens != null) {
            decodePer1k = lpm.calib_baseline_per_1000_output_tokens;
          } else if (lpm.decode_active_per_1000_output_tokens != null) {
            decodePer1k = lpm.decode_active_per_1000_output_tokens;
          } else if (lpm.decode_wh_per_1000_output_tokens != null) {
            decodePer1k = lpm.decode_wh_per_1000_output_tokens;
          }

          raplBatchSummaries.push({
            id: `${Date.now()}_${Math.random().toString(36).slice(2)}`,
            time: ts,
            runs: 1,
            meanWhPer1k: raplWhPer1k,
            medianWhPer1k: raplWhPer1k,
            stdWhPer1k: 0,
            p5WhPer1k: raplWhPer1k,
            p95WhPer1k: raplWhPer1k,
            cv: 0,
            meanInputTokens: inTok,
            medianInputTokens: inTok,
            meanOutputTokens: outTok,
            medianOutputTokens: outTok,
            meanPrefillIntensityPer1k: prefillPer1k,
            meanDecodeIntensityPer1k: decodePer1k,
          });
          renderRaplBatchTable();
        }
      }

      // Resolve any pending batch run
      if (batchRunning && typeof window._raplBatchResolve === 'function') {
        const resolve = window._raplBatchResolve;
        window._raplBatchResolve = null;
        resolve(data);
      }

      // Resolve any pending crossover run
      if (typeof window._raplCrossoverResolve === 'function') {
        const resolveX = window._raplCrossoverResolve;
        window._raplCrossoverResolve = null;
        resolveX(data);
      }
    }

    async function runRaplBatchHandler() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        alert('WebSocket not connected. Please refresh the page.');
        return;
      }

      const runsInput = document.getElementById('raplBatchRuns');
      const totalRuns = parseInt(runsInput.value, 10) || 1;

      // Prepare CLI terminal
      if (cliLog) cliLog.innerHTML = '';
      openCliModal();
      appendCliLog(`üìä Starting RAPL batch: ${totalRuns} run(s) with current query + injections`);

      batchRunning = true;
      batchStopRequested = false;
      let completed = 0;
      const raplValues = [];
      const raplTotalWhValues = [];
      const ttftArr = [];
      const decodeArr = [];
      const runDurArr = [];
      const thinkTokArr = [];
      const inputTokensArr = [];
      const outputTokensArr = [];
      const prefillIntensityArr = [];
      const decodeIntensityArr = [];
      const prefillWhArr = [];
      const decodeWhArr = [];
      _raplBatchFirstDuration = null;

      for (let i = 0; i < totalRuns; i++) {
        if (batchStopRequested) {
          appendCliLog(`‚èπ Batch stop requested after ${completed} run(s).`);
          break;
        }

        appendCliLog(`\n===== Batch Run ${i + 1}/${totalRuns} =====`);

        // Log current prompt and injections for this run
        const currentQuery = userPrompt.value.trim();
        appendCliLog(`üìù User query: ${currentQuery || '(empty)'}`);
        const injList = getInjections();
        if (injList.length > 0) {
          appendCliLog('üîß Injections:');
          injList.forEach((inj, idx) => {
            appendCliLog(`  [${idx + 1}] ${inj.description || 'Unnamed'}: ${inj.content.substring(0, 200)}${inj.content.length > 200 ? '‚Ä¶' : ''}`);
          });
        } else {
          appendCliLog('üîß Injections: (none)');
        }

        let payload;
        try { payload = buildEnergyPayload(true); } catch (e) { alert(e.message); return; }
        const base = userPrompt.value.trim();
        // Create a padding string that tokenizes into many distinct tokens across models
        // Use space-separated alphanumeric tokens to avoid aggressive BPE merges
        const padWordCount = Math.max(0, 100);
        const pad = padWordCount > 0 ? Array.from({ length: padWordCount }, (_, k) => `w${k}`).join(' ') : '';
        payload.user_prompt = base + (pad ? ('\n' + pad) : '');
        payload.user = payload.user_prompt;

        ws.send(JSON.stringify(payload));

        const data = await new Promise(resolve => {
          window._raplBatchResolve = resolve;
        });

        if (data && data.basic_metrics) {
          completed++;
          const totalTokens = data.basic_metrics.total_tokens;
          const promptTokens = data.basic_metrics.prompt_tokens ?? null;
          const completionTokens = data.basic_metrics.completion_tokens ?? null;
          const latency = data.basic_metrics.latency;
          const energyWh = data.energy_metrics.watt_hours_consumed;
          const lpm = data.live_power_metrics || {};
          const raplWhPer1k = lpm && lpm.measured_wh_per_1000_tokens;
          const raplTotalWh = (lpm && lpm.total_wh != null) ? lpm.total_wh : null;
          const ttft = lpm && lpm.ttft_seconds;
          const decDur = lpm && lpm.decode_duration_seconds;
          const runDur = lpm && lpm.run_duration_seconds;
          const thinkTok = (data.token_metrics && data.token_metrics.breakdown && data.token_metrics.breakdown.generation && (data.token_metrics.breakdown.generation.thinking_tokens != null)) ? data.token_metrics.breakdown.generation.thinking_tokens : null;

          let prefillPer1k = null;
          if (lpm && lpm.calib_prefill_per_1000_input_tokens != null) {
            prefillPer1k = lpm.calib_prefill_per_1000_input_tokens;
          } else if (lpm && lpm.prefill_active_per_1000_input_tokens != null) {
            prefillPer1k = lpm.prefill_active_per_1000_input_tokens;
          } else if (lpm && lpm.prefill_wh_per_1000_input_tokens != null) {
            prefillPer1k = lpm.prefill_wh_per_1000_input_tokens;
          }

          let decodePer1k = null;
          if (lpm && lpm.calib_baseline_per_1000_output_tokens != null) {
            decodePer1k = lpm.calib_baseline_per_1000_output_tokens;
          } else if (lpm && lpm.decode_active_per_1000_output_tokens != null) {
            decodePer1k = lpm.decode_active_per_1000_output_tokens;
          } else if (lpm && lpm.decode_wh_per_1000_output_tokens != null) {
            decodePer1k = lpm.decode_wh_per_1000_output_tokens;
          }

          let prefillWhRun = null;
          if (lpm) {
            if (lpm.calib_prefill_est_wh != null) {
              prefillWhRun = lpm.calib_prefill_est_wh;
            } else if (lpm.prefill_wh_active != null) {
              prefillWhRun = lpm.prefill_wh_active;
            } else if (lpm.prefill_wh != null) {
              prefillWhRun = lpm.prefill_wh;
            }
          }

          let decodeWhRun = null;
          if (lpm) {
            if (lpm.calib_expected_decode_wh != null) {
              decodeWhRun = lpm.calib_expected_decode_wh;
            } else if (lpm.decode_wh_active != null) {
              decodeWhRun = lpm.decode_wh_active;
            } else if (lpm.decode_wh != null) {
              decodeWhRun = lpm.decode_wh;
            }
          }

          if (raplWhPer1k != null) raplValues.push(raplWhPer1k);
          if (raplTotalWh != null) raplTotalWhValues.push(raplTotalWh);
          if (promptTokens != null) inputTokensArr.push(promptTokens);
          if (completionTokens != null) outputTokensArr.push(completionTokens);
          if (typeof ttft === 'number') ttftArr.push(ttft);
          if (typeof decDur === 'number') decodeArr.push(decDur);
          if (typeof runDur === 'number') runDurArr.push(runDur);
          if (typeof thinkTok === 'number') thinkTokArr.push(thinkTok);
          if (prefillPer1k != null) prefillIntensityArr.push(prefillPer1k);
          if (decodePer1k != null) decodeIntensityArr.push(decodePer1k);
          if (prefillWhRun != null) prefillWhArr.push(prefillWhRun);
          if (decodeWhRun != null) decodeWhArr.push(decodeWhRun);

          // Record first-run duration for ETA
          if (_raplBatchFirstDuration === null && latency && latency > 0) {
            _raplBatchFirstDuration = latency;
          }

          appendCliLog(
            `Run ${completed}: input=${promptTokens ?? 'n/a'} tok, output=${completionTokens ?? 'n/a'} tok, total=${totalTokens}, ` +
            `latency=${latency.toFixed(2)}s, energy=${energyWh.toFixed(4)} Wh, ` +
            `TTFT=${(typeof ttft === 'number') ? ttft.toFixed(3) : 'n/a'}s, ` +
            `Decode=${(typeof decDur === 'number') ? decDur.toFixed(3) : 'n/a'}s, ` +
            `RAPL Total Wh=${raplTotalWh != null ? raplTotalWh.toFixed(6) : 'n/a'}, ` +
            `RAPL Wh/1K=${raplWhPer1k != null ? raplWhPer1k.toFixed(4) : 'n/a'}`
          );

          // Estimated remaining time based on first run
          if (_raplBatchFirstDuration !== null && completed < totalRuns) {
            const remainingRuns = totalRuns - completed;
            const etaSeconds = remainingRuns * _raplBatchFirstDuration;
            const minutes = Math.floor(etaSeconds / 60);
            const seconds = Math.round(etaSeconds % 60);
            appendCliLog(
              `  Approx. time remaining: ${minutes > 0 ? minutes + 'm ' : ''}${seconds}s for ${remainingRuns} run(s)`
            );
          }
        } else {
          appendCliLog('‚ö†Ô∏è Run returned no basic metrics; skipping from stats.');
        }
      }

      batchRunning = false;
      batchStopRequested = false;

      if (raplValues.length > 0) {
        const meanOf = arr => arr.reduce((s, x) => s + x, 0) / arr.length;
        const medianOf = arr => { const a = [...arr].sort((a, b) => a - b); const n = a.length; return n % 2 ? a[(n - 1) / 2] : 0.5 * (a[n / 2 - 1] + a[n / 2]); };
        const sorted = [...raplValues].sort((a, b) => a - b);
        const n = sorted.length;
        const mean = sorted.reduce((s, x) => s + x, 0) / n;
        const median = n % 2 === 1 ? sorted[(n - 1) / 2] : 0.5 * (sorted[n / 2 - 1] + sorted[n / 2]);
        const varVal = sorted.reduce((s, x) => s + (x - mean) * (x - mean), 0) / n;
        const std = Math.sqrt(varVal);
        const p5 = sorted[Math.max(Math.floor(n * 0.05) - 1, 0)];
        const p95 = sorted[Math.min(Math.floor(n * 0.95), n - 1)];
        const cv = std / mean;

        // Measured Total Wh stats (if available)
        let meanTotWh = null;
        let medianTotWh = null;
        if (raplTotalWhValues.length > 0) {
          const sortedWh = [...raplTotalWhValues].sort((a, b) => a - b);
          const nwh = sortedWh.length;
          meanTotWh = sortedWh.reduce((s, x) => s + x, 0) / nwh;
          medianTotWh = nwh % 2 === 1 ? sortedWh[(nwh - 1) / 2] : 0.5 * (sortedWh[nwh / 2 - 1] + sortedWh[nwh / 2]);
        }

        // Thinking tokens and timing stats
        const meanThink = thinkTokArr.length ? meanOf(thinkTokArr) : null;
        const medianThink = thinkTokArr.length ? medianOf(thinkTokArr) : null;
        const meanTTFT = ttftArr.length ? meanOf(ttftArr) : null;
        const medianTTFT = ttftArr.length ? medianOf(ttftArr) : null;
        const meanDecode = decodeArr.length ? meanOf(decodeArr) : null;
        const medianDecode = decodeArr.length ? medianOf(decodeArr) : null;
        const meanRunDur = runDurArr.length ? meanOf(runDurArr) : null;
        const medianRunDur = runDurArr.length ? medianOf(runDurArr) : null;

        // Compute token statistics
        const meanIn = inputTokensArr.length ? (inputTokensArr.reduce((s, x) => s + x, 0) / inputTokensArr.length) : null;
        const meanOut = outputTokensArr.length ? (outputTokensArr.reduce((s, x) => s + x, 0) / outputTokensArr.length) : null;
        const medIn = inputTokensArr.length ? (() => {
          const t = [...inputTokensArr].sort((a, b) => a - b); const n2 = t.length; return n2 % 2 ? t[(n2 - 1) / 2] : 0.5 * (t[n2 / 2 - 1] + t[n2 / 2]);
        })() : null;
        const medOut = outputTokensArr.length ? (() => {
          const t = [...outputTokensArr].sort((a, b) => a - b); const n2 = t.length; return n2 % 2 ? t[(n2 - 1) / 2] : 0.5 * (t[n2 / 2 - 1] + t[n2 / 2]);
        })() : null;

        const meanPrefillInt = prefillIntensityArr.length ? meanOf(prefillIntensityArr) : null;
        const meanDecodeInt = decodeIntensityArr.length ? meanOf(decodeIntensityArr) : null;
        const medianPrefillInt = prefillIntensityArr.length ? medianOf(prefillIntensityArr) : null;
        const medianDecodeInt = decodeIntensityArr.length ? medianOf(decodeIntensityArr) : null;

        // Calculate injected tokens from the last result (assuming constant for batch)
        let injectedTokensVal = 0;
        if (_raplLastBatchResult && _raplLastBatchResult.token_metrics && _raplLastBatchResult.token_metrics.breakdown) {
          injectedTokensVal = _raplLastBatchResult.token_metrics.breakdown.injected?.total_injection_tokens || 0;
        }

        appendCliLog('\nüìà RAPL Batch Summary (UI prompt + injections)');
        appendCliLog(`  Successful runs: ${n}`);
        appendCliLog(`  Mean:   ${mean.toFixed(4)} Wh/1K`);
        appendCliLog(`  Median: ${median.toFixed(4)} Wh/1K`);
        appendCliLog(`  Std:    ${std.toFixed(4)} Wh/1K`);
        appendCliLog(`  5‚Äì95%:  ${p5.toFixed(4)} ‚Äì ${p95.toFixed(4)} Wh/1K`);
        appendCliLog(`  CV:     ${cv.toFixed(4)}`);
        if (meanTotWh != null || medianTotWh != null) {
          appendCliLog(`  Mean Total Wh:   ${meanTotWh != null ? meanTotWh.toFixed(6) : 'n/a'} Wh`);
          appendCliLog(`  Median Total Wh: ${medianTotWh != null ? medianTotWh.toFixed(6) : 'n/a'} Wh`);
        }
        if (meanThink != null || medianThink != null) {
          appendCliLog(`  Thinking tokens Œº/med: ${meanThink != null ? meanThink.toFixed(0) : 'n/a'} / ${medianThink != null ? medianThink.toFixed(0) : 'n/a'}`);
        }
        if (meanTTFT != null || medianTTFT != null) {
          appendCliLog(`  TTFT Œº/med: ${meanTTFT != null ? meanTTFT.toFixed(3) : 'n/a'}s / ${medianTTFT != null ? medianTTFT.toFixed(3) : 'n/a'}s`);
        }
        if (meanDecode != null || medianDecode != null) {
          appendCliLog(`  Decode Œº/med: ${meanDecode != null ? meanDecode.toFixed(3) : 'n/a'}s / ${medianDecode != null ? medianDecode.toFixed(3) : 'n/a'}s`);
        }
        if (meanRunDur != null || medianRunDur != null) {
          appendCliLog(`  Run Œº/med: ${meanRunDur != null ? meanRunDur.toFixed(3) : 'n/a'}s / ${medianRunDur != null ? medianRunDur.toFixed(3) : 'n/a'}s`);
        }
        if (meanIn != null || meanOut != null) {
          appendCliLog(`  Input tokens Œº: ${meanIn != null ? meanIn.toFixed(0) : 'n/a'}`);
          appendCliLog(`  Output tokens Œº: ${meanOut != null ? meanOut.toFixed(0) : 'n/a'}`);
        }
        if (injectedTokensVal > 0) {
          appendCliLog(`  Injected tokens: ${injectedTokensVal}`);
        }

        // Store a simple summary row for the batch table
        const now = new Date();
        const ts = now.toLocaleTimeString();
        raplBatchSummaries.push({
          id: `${Date.now()}_${Math.random().toString(36).slice(2)}`,
          time: ts,
          runs: n,
          injectedTokens: injectedTokensVal,
          meanWhPer1k: mean,
          medianWhPer1k: median,
          stdWhPer1k: std,
          p5WhPer1k: p5,
          p95WhPer1k: p95,
          cv,
          meanInputTokens: meanIn,
          medianInputTokens: medIn,
          meanOutputTokens: meanOut,
          medianOutputTokens: medOut,
          meanTotalWh: meanTotWh,
          medianTotalWh: medianTotWh,
          meanThinkingTokens: meanThink,
          medianThinkingTokens: medianThink,
          meanTTFT: meanTTFT,
          medianTTFT: medianTTFT,
          meanDecode: meanDecode,
          medianDecode: medianDecode,
          meanRunDur: meanRunDur,
          medianRunDur: medianRunDur,
          meanPrefillIntensityPer1k: meanPrefillInt,
          medianPrefillIntensityPer1k: medianPrefillInt,
          meanDecodeIntensityPer1k: meanDecodeInt,
          medianDecodeIntensityPer1k: medianDecodeInt,
          meanPrefillWh: meanPrefillWh,
          meanDecodeWh: meanDecodeWh,
        });
        renderRaplBatchTable();
      } else {
        appendCliLog('\n‚ö†Ô∏è No valid RAPL Wh/1K values collected in batch.');
      }

      // After batch completes, if we have a last successful result, apply it
      // to the main single-run UI so you can inspect one concrete run.
      if (_raplLastBatchResult) {
        currentTestResults = _raplLastBatchResult;
        updateEnergyDisplay(_raplLastBatchResult.energy_metrics);
        updateResultsDisplay(_raplLastBatchResult);
        const raplIntensity = (_raplLastBatchResult.live_power_metrics && _raplLastBatchResult.live_power_metrics.measured_wh_per_1000_tokens != null)
          ? _raplLastBatchResult.live_power_metrics.measured_wh_per_1000_tokens
          : null;
        updateMainResultsChart(_raplLastBatchResult);
        await updateSessionSummary();
        analyzeModificationImpact(_raplLastBatchResult);
      }
    }

    async function runRaplCrossoverHandler() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        alert('WebSocket not connected. Please refresh the page.');
        return;
      }
      // Ensure CLI modal is visible for live progress
      openCliModal();

      const startTokens = parseInt(document.getElementById('crossoverStartTokens').value) || 100;
      const stepTokens = parseInt(document.getElementById('crossoverStepTokens').value) || 200;
      const maxSteps = parseInt(document.getElementById('crossoverMaxSteps').value) || 10;
      const tableBody = document.getElementById('raplCrossoverTableBody');
      if (tableBody) tableBody.innerHTML = '';

      appendCliLog('üö¶ Starting RAPL Crossover Finder...');
      let tokensTarget = startTokens;
      for (let i = 1; i <= maxSteps; i++) {
        // Build payload and inflate user prompt approximately to reach tokensTarget (heuristic: 1 token ‚âà 4 chars)
        let payload;
        try { payload = buildEnergyPayload(true); } catch (e) { alert(e.message); return; }
        const base = userPrompt.value.trim();
        // Create a padding string that tokenizes into many distinct tokens across models
        // Use space-separated alphanumeric tokens to avoid aggressive BPE merges
        const padWordCount = Math.max(0, tokensTarget);
        const pad = padWordCount > 0 ? Array.from({ length: padWordCount }, (_, k) => `w${k}`).join(' ') : '';
        payload.user_prompt = base + (pad ? ('\n' + pad) : '');
        payload.user = payload.user_prompt;

        ws.send(JSON.stringify(payload));
        const data = await new Promise(resolve => { window._raplCrossoverResolve = resolve; });

        const lpm = data && data.live_power_metrics ? data.live_power_metrics : {};
        const promptTok = data && data.basic_metrics ? (data.basic_metrics.prompt_tokens ?? null) : null;
        const preWh = (lpm.prefill_wh != null) ? lpm.prefill_wh : null;
        const decWh = (lpm.decode_wh != null) ? lpm.decode_wh : null;
        const totWh = (lpm.total_wh != null) ? lpm.total_wh : null;
        const wh1k = (lpm.measured_wh_per_1000_tokens != null) ? lpm.measured_wh_per_1000_tokens : null;

        // Append row
        if (tableBody) {
          const tr = document.createElement('tr');
          tr.className = 'hover:bg-gray-50';
          tr.innerHTML = `
            <td class="px-3 py-2 whitespace-nowrap text-gray-500">${i}</td>
            <td class="px-3 py-2 whitespace-nowrap text-gray-900">${promptTok ?? 'n/a'}</td>
            <td class="px-3 py-2 whitespace-nowrap">${preWh != null ? preWh.toFixed(6) : '-'}</td>
            <td class="px-3 py-2 whitespace-nowrap">${decWh != null ? decWh.toFixed(6) : '-'}</td>
            <td class="px-3 py-2 whitespace-nowrap">${totWh != null ? totWh.toFixed(6) : '-'}</td>
            <td class="px-3 py-2 whitespace-nowrap">${wh1k != null ? wh1k.toFixed(4) : '-'}</td>
            <td class="px-3 py-2 whitespace-nowrap">${(preWh != null && decWh != null && preWh > decWh) ? '‚úÖ' : ''}</td>
          `;
          tableBody.appendChild(tr);
        }

        if (preWh != null && decWh != null && preWh > decWh) {
          appendCliLog(`üõë Crossover reached at run ${i} (Prefill > Decode).`);
          break;
        }
        tokensTarget += stepTokens;
      }
      appendCliLog('‚úÖ Crossover Finder finished.');
    }
    function updateEnergyDisplay(energyMetrics) {
      let energy = (energyMetrics && typeof energyMetrics.watt_hours_consumed === 'number')
        ? energyMetrics.watt_hours_consumed
        : 0;
      // Prefer live RAPL total Wh when available for per-run carbon and energy display
      const lpm = currentTestResults && currentTestResults.live_power_metrics
        ? currentTestResults.live_power_metrics
        : null;
      if (lpm && typeof lpm.total_wh === 'number') {
        energy = lpm.total_wh;
      }
      // Determine carbon: prefer backend carbon_grams_co2 if present, otherwise derive from grid factor
      const carbon = energy * currentEmissionFactor;

      // Update Main KPIs
      if (kpiEnergyWh) kpiEnergyWh.textContent = energy > 0 ? `${energy.toFixed(4)} Wh` : '-';
      if (kpiCarbonMain) {
        if (energy > 0 && Number.isFinite(carbon)) {
          kpiCarbonMain.textContent = `${carbon.toFixed(4)} gCO2`;
        } else {
          kpiCarbonMain.textContent = '-';
        }
      }

      // Calculate and display efficiency and speed from current results if available
      if (currentTestResults && currentTestResults.basic_metrics) {
        const bm = currentTestResults.basic_metrics;
        const totalTokens = bm.total_tokens || 0;
        const outputTokens = bm.completion_tokens || 0;
        const inputTokens = bm.prompt_tokens || 0;

        // Default Intensity: Wh / 1k output tokens (matches traditional benchmark view)
        // The user can toggle the chart, but the card usually shows the primary metric.
        // Let's use the 'Intensity Score' from backend which is typically Wh/1k output
        const effScore = energyMetrics.energy_efficiency_score;
        if (kpiIntensityMain) {
          kpiIntensityMain.textContent = effScore > 0 ? `${effScore.toFixed(4)}` : '-';
        }

        if (kpiSpeedMain) {
          kpiSpeedMain.textContent = bm.latency ? bm.latency.toFixed(2) : '-';
        }
        if (kpiSpeedDetail) {
          kpiSpeedDetail.textContent = 'Total time (s)';
        }
      }

      // Legacy per-run display (kept for compatibility)
      if (testEnergy) {
        testEnergy.textContent = `${energy.toFixed(4)} Wh`;
      }
      if (carbonImpact) {
        carbonImpact.textContent = `${carbon.toFixed(2)} gCO2`;
      }
      // Per-run RAPL metrics (if available on this response)
      if (currentTestResults && currentTestResults.live_power_metrics) {
        const lpm = currentTestResults.live_power_metrics;
        if (lpm.measured_wh_per_1000_tokens != null) {
          raplIntensity.textContent = `${lpm.measured_wh_per_1000_tokens.toFixed(4)} Wh/1K`;
        }

        // Update phase energy chart
        updatePhaseEnergyChart(lpm);
        // Prefill/Decode display if available
        const prefillEl = document.getElementById('prefillEnergy');
        const decodeEl = document.getElementById('decodeEnergy');
        if (prefillEl) {
          const prefillVal = (lpm.calib_prefill_est_wh != null) ? lpm.calib_prefill_est_wh : ((lpm.prefill_wh_active != null) ? lpm.prefill_wh_active : lpm.prefill_wh);
          if (prefillVal != null) {
            const per1kIn = (lpm.calib_prefill_per_1000_input_tokens != null) ? lpm.calib_prefill_per_1000_input_tokens : ((lpm.prefill_active_per_1000_input_tokens != null) ? lpm.prefill_active_per_1000_input_tokens : lpm.prefill_wh_per_1000_input_tokens);
            prefillEl.textContent = `${prefillVal.toFixed(6)} Wh${per1kIn != null ? ` (${per1kIn.toFixed(4)} Wh/1K input)` : ''}`;
          } else {
            prefillEl.textContent = '-';
          }
        }
        if (decodeEl) {
          const decodeVal = (lpm.calib_expected_decode_wh != null) ? lpm.calib_expected_decode_wh : ((lpm.decode_wh_active != null) ? lpm.decode_wh_active : lpm.decode_wh);
          if (decodeVal != null) {
            const per1kOut = (lpm.calib_baseline_per_1000_output_tokens != null) ? lpm.calib_baseline_per_1000_output_tokens : ((lpm.decode_active_per_1000_output_tokens != null) ? lpm.decode_active_per_1000_output_tokens : lpm.decode_wh_per_1000_output_tokens);
            decodeEl.textContent = `${decodeVal.toFixed(6)} Wh${per1kOut != null ? ` (${per1kOut.toFixed(4)} Wh/1K output)` : ''}`;
          } else {
            decodeEl.textContent = '-';
          }
        }

        // Update Prefill / Decode / Total chart (only when values available)
        const prefillChartVal = (lpm.calib_prefill_est_wh != null) ? lpm.calib_prefill_est_wh : ((lpm.prefill_wh_active != null) ? lpm.prefill_wh_active : lpm.prefill_wh);
        const decodeChartVal = (lpm.calib_expected_decode_wh != null) ? lpm.calib_expected_decode_wh : ((lpm.decode_wh_active != null) ? lpm.decode_wh_active : lpm.decode_wh);
        const totalChartVal = (lpm.total_wh_active != null) ? lpm.total_wh_active : (lpm.total_wh != null ? lpm.total_wh : ((prefillChartVal != null && decodeChartVal != null) ? prefillChartVal + decodeChartVal : null));
        if (prefillDecodeChart && prefillChartVal != null && decodeChartVal != null && totalChartVal != null) {
          const labels = prefillDecodeChart.data.labels;
          labels.push(`Test ${labels.length + 1}`);
          if (labels.length > 20) labels.shift();
          const ds0 = prefillDecodeChart.data.datasets[0].data; // Prefill
          const ds1 = prefillDecodeChart.data.datasets[1].data; // Decode
          const ds2 = prefillDecodeChart.data.datasets[2].data; // Total
          ds0.push(prefillChartVal);
          ds1.push(decodeChartVal);
          ds2.push(totalChartVal);
          if (ds0.length > 20) ds0.shift();
          if (ds1.length > 20) ds1.shift();
          if (ds2.length > 20) ds2.shift();
          prefillDecodeChart.update();
        }
      } else {
        if (raplIntensity) raplIntensity.textContent = '0.00';
        const prefillEl = document.getElementById('prefillEnergy');
        const decodeEl = document.getElementById('decodeEnergy');
        if (prefillEl) prefillEl.textContent = '-';
        if (decodeEl) decodeEl.textContent = '-';
      }

      // Update energy bar
      let energyLevel = 'low';
      let barWidth = Math.min(energy * 10, 100); // Scale for visualization

      if (energy > 0.5) energyLevel = 'medium';
      if (energy > 1.0) energyLevel = 'high';

      if (testEnergyBar) {
        testEnergyBar.style.width = `${barWidth}%`;
        testEnergyBar.className = `energy-bar energy-${energyLevel} h-4 rounded-full`;
      }
    }

    let tokenChart = null;

    function updateResultsDisplay(data) {
      resultStrategy.textContent = data.strategy;
      resultTokens.textContent = data.basic_metrics.total_tokens;
      resultLatency.textContent = `${data.basic_metrics.latency.toFixed(2)}s`;
      resultTokensPerSec.textContent = data.basic_metrics.tokens_per_second.toFixed(1);

      // Mirror into KPI timing row
      if (kpiLatency) kpiLatency.textContent = `${data.basic_metrics.latency.toFixed(2)}s`;
      if (kpiTokensPerSec) kpiTokensPerSec.textContent = data.basic_metrics.tokens_per_second.toFixed(1);

      // Update token breakdown display
      if (data.token_metrics && data.token_metrics.breakdown) {
        const breakdown = data.token_metrics.breakdown;
        const original = breakdown.original || {};
        const generation = breakdown.generation || {};
        const injected = breakdown.injected || {};
        const verification = breakdown.verification || {};

        const userTokens = (original.user_tokens != null) ? original.user_tokens : (original.total_original_tokens ?? 0);
        const thinkingTokens = generation.thinking_tokens ?? 0;
        const contentTokens = (generation.content_tokens != null) ? generation.content_tokens : (generation.direct_output_tokens ?? 0);
        const systemTokens = injected.system_prompt_tokens ?? 0;
        const injOverheadTokens = injected.injection_overhead ?? 0;
        const toolOverheadTokens = injected.tool_integration_overhead ?? 0;
        const templateTokens = verification.template_overhead_tokens ?? 0;

        const totalOverheadTokens = systemTokens + injOverheadTokens + toolOverheadTokens + templateTokens;

        // Update summary text using user vs total middleware overhead
        document.getElementById('inputTokensVal').textContent = userTokens;
        document.getElementById('overheadTokensVal').textContent = totalOverheadTokens;
        const thinkEl = document.getElementById('thinkingTokensVal');
        if (thinkEl) thinkEl.textContent = thinkingTokens;
        document.getElementById('outputTokensVal').textContent = contentTokens;

        if (Array.isArray(breakdown.analysis_notes) && breakdown.analysis_notes.length > 0) {
          tokenAnalysisNotes.textContent = breakdown.analysis_notes.join('. ') + '.';
        }

        // RAPL energy metrics into Token Analysis summary if present
        const lpm = data.live_power_metrics || {};
        const prefillPer = document.getElementById('prefillPer1kIn');
        const decodePer = document.getElementById('decodePer1kOut');
        const ewPer = document.getElementById('ewOutPer1k');
        if (prefillPer) prefillPer.textContent = (lpm.calib_prefill_per_1000_input_tokens != null ? lpm.calib_prefill_per_1000_input_tokens : (lpm.prefill_active_per_1000_input_tokens != null ? lpm.prefill_active_per_1000_input_tokens : lpm.prefill_wh_per_1000_input_tokens)) != null ? (lpm.calib_prefill_per_1000_input_tokens != null ? lpm.calib_prefill_per_1000_input_tokens : (lpm.prefill_active_per_1000_input_tokens != null ? lpm.prefill_active_per_1000_input_tokens : lpm.prefill_wh_per_1000_input_tokens)).toFixed(4) : '-';
        if (decodePer) decodePer.textContent = (lpm.calib_baseline_per_1000_output_tokens != null ? lpm.calib_baseline_per_1000_output_tokens : (lpm.decode_active_per_1000_output_tokens != null ? lpm.decode_active_per_1000_output_tokens : lpm.decode_wh_per_1000_output_tokens)) != null ? (lpm.calib_baseline_per_1000_output_tokens != null ? lpm.calib_baseline_per_1000_output_tokens : (lpm.decode_active_per_1000_output_tokens != null ? lpm.decode_active_per_1000_output_tokens : lpm.decode_wh_per_1000_output_tokens)).toFixed(4) : '-';
        if (ewPer) ewPer.textContent = (lpm.measured_wh_per_1000_tokens != null) ? lpm.measured_wh_per_1000_tokens.toFixed(4) : '-';

        // Approximate energy share per token contributor using total energy
        const totals = breakdown.totals || {};
        const totalInputTokens = totals.total_input ?? 0;
        const totalOutputTokens = totals.total_output ?? 0;
        const totalTokensForShare = (totalInputTokens + totalOutputTokens) || 1;

        let energyForShare = null;
        if (lpm && typeof lpm.total_wh_active === 'number') {
          energyForShare = lpm.total_wh_active;
        } else if (lpm && typeof lpm.total_wh === 'number') {
          energyForShare = lpm.total_wh;
        } else if (data.energy_metrics && typeof data.energy_metrics.watt_hours_consumed === 'number') {
          energyForShare = data.energy_metrics.watt_hours_consumed;
        }

        // Update Chart
        const ctx = document.getElementById('tokenBreakdownChart').getContext('2d');

        if (tokenChart) {
          tokenChart.destroy();
        }

        tokenChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: ['Token Distribution'],
            datasets: [
              {
                label: 'User Query',
                data: [userTokens],
                backgroundColor: '#10b981', // Green
                barThickness: 40
              },
              {
                label: 'Base System Prompt',
                data: [systemTokens],
                backgroundColor: '#6366f1', // Indigo
                barThickness: 40
              },
              {
                label: 'Prompt Injections',
                data: [injOverheadTokens],
                backgroundColor: '#f59e0b', // Amber
                barThickness: 40
              },
              {
                label: 'Tool Integration',
                data: [toolOverheadTokens],
                backgroundColor: '#d97706', // Darker amber
                barThickness: 40
              },
              {
                label: 'Template / Serialization',
                data: [templateTokens],
                backgroundColor: '#6b7280', // Gray
                barThickness: 40
              },
              {
                label: 'Thinking Output',
                data: [thinkingTokens],
                backgroundColor: '#a855f7', // Purple
                barThickness: 40
              },
              {
                label: 'Visible Output',
                data: [contentTokens],
                backgroundColor: '#3b82f6', // Blue
                barThickness: 40
              }
            ]
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { stacked: true, title: { display: true, text: 'Tokens' } },
              y: { stacked: true, display: false }
            },
            plugins: {
              legend: { position: 'top' },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    let label = context.dataset.label || '';
                    const tokensVal = (context.parsed && typeof context.parsed.x === 'number') ? context.parsed.x : 0;
                    if (label) {
                      label += ': ';
                    }
                    label += tokensVal + ' tokens';
                    if (energyForShare != null && totalTokensForShare > 0 && tokensVal > 0) {
                      const share = tokensVal / totalTokensForShare;
                      const wh = energyForShare * share;
                      label += ` (‚âà ${wh.toFixed(6)} Wh)`;
                    }
                    return label;
                  }
                }
              }
            }
          }
        });
      }

      const lpm = data.live_power_metrics || {};
      const estEff = data.energy_metrics && typeof data.energy_metrics.energy_efficiency_score === 'number'
        ? data.energy_metrics.energy_efficiency_score
        : null;

      // Intensity comparison (Benchmark vs RAPL vs M_eff)
      let benchWhPer1k = null;
      if (lpm && typeof lpm.benchmark_wh_per_1000_tokens === 'number') {
        benchWhPer1k = lpm.benchmark_wh_per_1000_tokens;
      } else if (estEff != null) {
        benchWhPer1k = estEff;
      }

      const ellmWhPer1k = (lpm && typeof lpm.scaph_e_llm_wh_per_1000_tokens === 'number')
        ? lpm.scaph_e_llm_wh_per_1000_tokens
        : ((lpm && typeof lpm.measured_wh_per_1000_tokens === 'number') ? lpm.measured_wh_per_1000_tokens : null);

      const meffWhPer1k = (lpm && typeof lpm.model_compute_efficiency_wh_per_1000_tokens === 'number')
        ? lpm.model_compute_efficiency_wh_per_1000_tokens
        : null;

      if (kpiEffBenchmark) {
        kpiEffBenchmark.textContent = benchWhPer1k != null ? `${benchWhPer1k.toFixed(4)} Wh/1K` : '-';
      }
      if (kpiEffEllm) {
        kpiEffEllm.textContent = ellmWhPer1k != null ? `${ellmWhPer1k.toFixed(4)} Wh/1K` : '-';
      }
      if (kpiEffMeff) {
        kpiEffMeff.textContent = meffWhPer1k != null ? `${meffWhPer1k.toFixed(4)} Wh/1K` : '-';
      }

      // TTFT into KPI row
      if (kpiTtft) {
        const ttft = (lpm && typeof lpm.ttft_seconds === 'number') ? lpm.ttft_seconds : null;
        kpiTtft.textContent = ttft != null ? `${ttft.toFixed(3)}s` : '-';
      }

      const devEl = document.getElementById('mEffDeviation');
      if (devEl) {
        const devPct = (typeof lpm.m_eff_vs_e_llm_deviation_percent === 'number')
          ? lpm.m_eff_vs_e_llm_deviation_percent
          : null;
        if (devPct != null) {
          devEl.textContent = 'Œî M_eff vs E_llm: ' + devPct.toFixed(1) + '%';
          const excessive = devPct >= 20.0;
          devEl.classList.remove('text-slate-500', 'text-red-400');
          devEl.classList.add(excessive ? 'text-red-400' : 'text-slate-500');
        } else {
          devEl.textContent = 'Œî M_eff vs E_llm: n/a';
          devEl.classList.remove('text-red-400');
          devEl.classList.add('text-slate-500');
        }
      }
    }

    // --- NEW CHART LOGIC ---

    function setChartMode(mode) {
      currentChartMode = mode;
      // Update button styles
      ['Energy', 'Speed', 'Carbon'].forEach(m => {
        const btn = document.getElementById(`btnMode${m}`);
        if (btn) {
          if (m.toLowerCase() === mode) {
            btn.classList.remove('text-slate-400', 'hover:text-white');
            btn.classList.add('bg-indigo-600', 'text-white', 'shadow-lg');
          } else {
            btn.classList.add('text-slate-400', 'hover:text-white');
            btn.classList.remove('bg-indigo-600', 'text-white', 'shadow-lg');
          }
        }
      });

      // Show/hide electricity grid dropdown based on Carbon mode
      const gridContainer = document.getElementById('electricityGridContainer');
      if (gridContainer) {
        if (mode === 'carbon') {
          gridContainer.classList.remove('hidden');
        } else {
          gridContainer.classList.add('hidden');
        }
      }

      updateMainChart();
    }

    function updateMainChartVisibility() {
      updateMainChart();
    }

    function updateMainResultsChart(data) {
      if (!mainResultsChart) return;

      const bm = data.basic_metrics || {};
      const em = data.energy_metrics || {};
      const lpm = data.live_power_metrics || {};

      const baseEnergyWh = (lpm && typeof lpm.total_wh === 'number') ? lpm.total_wh : (em.watt_hours_consumed || 0);

      const newItem = {
        energyWh: em.watt_hours_consumed || 0,
        carbonBaseWh: baseEnergyWh,
        inputTokens: bm.prompt_tokens || 0,
        outputTokens: bm.completion_tokens || 0,
        totalTokens: bm.total_tokens || 0,
        latency: bm.latency || 0,
        tokensPerSec: bm.tokens_per_second || 0,
        ttft: lpm.ttft_seconds || 0,
        decodeDuration: lpm.decode_duration_seconds || 0,
        raplEnergyWh: lpm.total_wh || 0,
        // Store raw RAPL Wh if available, otherwise 0
        timestamp: new Date().toLocaleTimeString()
      };

      energyHistory.push(newItem);
      if (energyHistory.length > 30) energyHistory.shift();

      updateMainChart();
    }

    function updateMainChart() {
      if (!mainResultsChart) return;

      const showRapl = document.getElementById('chartToggleRapl').checked;
      const showEst = document.getElementById('chartToggleEst').checked;
      const normMode = document.getElementById('chartNormSelect').value; // 'output', 'input', 'total'

      const labels = energyHistory.map((_, i) => `Run ${i + 1}`);
      const datasets = [];

      // Helper to get normalization divisor (in thousands)
      const getDivisor = (item) => {
        let tokens = 0;
        if (normMode === 'input') tokens = item.inputTokens;
        else if (normMode === 'total') tokens = item.totalTokens;
        else tokens = item.outputTokens; // default output
        return tokens > 0 ? (tokens / 1000.0) : 0;
      };

      if (currentChartMode === 'energy') {
        // Dataset 1: Benchmark Intensity (theoretical, from selected baseline)
        if (showEst) {
          const benchOpt = benchmarkSwitcher && benchmarkSwitcher.selectedOptions
            ? benchmarkSwitcher.selectedOptions[0]
            : null;
          const benchWh = benchOpt ? parseFloat(benchOpt.dataset.wh || '0') : NaN;

          const dataEst = energyHistory.map(item => {
            if (!benchOpt || !Number.isFinite(benchWh) || benchWh <= 0) return null;
            const outTok = item.outputTokens || 0;
            const inTok = item.inputTokens || 0;
            const totalTok = item.totalTokens || (inTok + outTok);

            // Convert baseline spec (Wh/1k output tokens) into the requested normalization
            if (normMode === 'output') {
              return benchWh;
            } else if (normMode === 'input') {
              if (inTok <= 0 || outTok <= 0) return null;
              // Scale by output/input ratio so energy-per-token remains consistent
              return benchWh * (outTok / inTok);
            } else if (normMode === 'total') {
              if (totalTok <= 0 || outTok <= 0) return null;
              return benchWh * (outTok / totalTok);
            }
            return benchWh;
          });

          datasets.push({
            label: `Benchmark Intensity (Wh/1k ${normMode})`,
            data: dataEst,
            borderColor: '#6366f1', // Indigo
            backgroundColor: 'rgba(99, 102, 241, 0.1)',
            tension: 0.3,
            yAxisID: 'y'
          });
        }

        // Dataset 2: RAPL Intensity (Actual)
        if (showRapl) {
          const dataRapl = energyHistory.map(item => {
            if (!item.raplEnergyWh) return null;
            const div = getDivisor(item);
            return div > 0 ? (item.raplEnergyWh / div) : 0;
          });
          datasets.push({
            label: `RAPL Intensity (Wh/1k ${normMode})`,
            data: dataRapl,
            borderColor: '#ef4444', // Red
            backgroundColor: 'rgba(239, 68, 68, 0.1)',
            borderDash: [5, 5],
            tension: 0.3,
            yAxisID: 'y'
          });
        }

        // Optional: Total Energy overlay (on separate axis)? 
        // User asked for "Total Wh" and "Wh/1000" plottable. 
        // Mixing absolute and relative on same chart was the original complaint.
        // Let's keep this mode focused on Intensity as that's the primary scientific metric here.
        // Or we can add Total Wh as a bar?
        // Let's add Total Wh as a bar on a secondary axis if they want to see it?
        // User said: "with two different measures on the Y axis... very noisy".
        // So let's stick to Intensity in this view, maybe add a separate "Total Energy" view later if needed?
        // Actually user listed: "total wh, wh/1000 e-tokens ... All of these should be plottable per run".
        // Let's add Total Wh as a dataset but maybe hidden by default? Or just stick to the requested clean view.
        // Let's stick to efficiency for the "Energy" view as it normalizes properly.
      }
      else if (currentChartMode === 'speed') {
        // Show total, prefill (TTFT), and decode times in seconds
        datasets.push({
          label: 'Total time (s)',
          data: energyHistory.map(h => h.latency),
          borderColor: '#10b981', // Green
          backgroundColor: 'rgba(16, 185, 129, 0.1)',
          tension: 0.3,
          yAxisID: 'y'
        });
        datasets.push({
          label: 'Prefill (TTFT, s)',
          data: energyHistory.map(h => h.ttft || 0),
          borderColor: '#3b82f6', // Blue
          backgroundColor: 'rgba(59, 130, 246, 0.1)',
          tension: 0.3,
          borderDash: [4, 4],
          yAxisID: 'y'
        });
        datasets.push({
          label: 'Decode time (s)',
          data: energyHistory.map(h => {
            const ttft = h.ttft || 0;
            const dec = h.decodeDuration || 0;
            if (dec > 0) return dec;
            if (h.latency && ttft) return Math.max(h.latency - ttft, 0);
            return 0;
          }),
          borderColor: '#f97316', // Orange
          backgroundColor: 'rgba(249, 115, 22, 0.1)',
          tension: 0.3,
          yAxisID: 'y'
        });
      }
      else if (currentChartMode === 'carbon') {
        const dataCarbon = energyHistory.map(item => {
          const baseWh = (typeof item.carbonBaseWh === 'number') ? item.carbonBaseWh : (item.energyWh || 0);
          return baseWh * currentEmissionFactor;
        });
        datasets.push({
          label: `Total Carbon (gCO2)`,
          data: dataCarbon,
          borderColor: '#22c55e', // Green
          backgroundColor: 'rgba(34, 197, 94, 0.1)',
          tension: 0.3,
          fill: true,
          yAxisID: 'y'
        });
      }

      mainResultsChart.data.labels = labels;
      mainResultsChart.data.datasets = datasets;

      // Update scales
      if (currentChartMode === 'speed') {
        mainResultsChart.options.scales.y.title.text = 'Seconds';
        mainResultsChart.options.scales.y1.display = false;
      } else {
        mainResultsChart.options.scales.y.title.text = currentChartMode === 'carbon' ? 'Total gCO2' : 'Wh / 1k tokens';
        mainResultsChart.options.scales.y1.display = false;
      }

      mainResultsChart.update();
    }

    function initMainResultsChart() {
      const canvas = document.getElementById('mainResultsChart');
      if (!canvas || !window.Chart) return;

      const ctx = canvas.getContext('2d');
      mainResultsChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: []
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: {
              ticks: { color: '#94a3b8' },
              grid: { color: '#334155' }
            },
            y: {
              position: 'left',
              ticks: { color: '#94a3b8' },
              grid: { color: '#334155' },
              title: { display: true, text: 'Value', color: '#cbd5e1' },
              beginAtZero: true
            },
            y1: {
              position: 'right',
              display: false,
              grid: { drawOnChartArea: false },
              ticks: { color: '#94a3b8' },
              title: { display: true, text: 'Value', color: '#cbd5e1' },
              beginAtZero: true
            },
          },
          plugins: {
            legend: {
              labels: { color: '#cbd5e1' },
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              backgroundColor: 'rgba(15, 23, 42, 0.9)',
              titleColor: '#f8fafc',
              bodyColor: '#e2e8f0',
              borderColor: '#475569',
              borderWidth: 1
            }
          },
        },
      });
    }

    function updatePhaseEnergyChart(livePowerMetrics) {
      if (!phaseEnergyChart || !livePowerMetrics) return;

      const prefillRaw = livePowerMetrics.prefill_wh;
      const decodeRaw = livePowerMetrics.decode_wh;
      const prefillActive = livePowerMetrics.prefill_wh_active;
      const decodeActive = livePowerMetrics.decode_wh_active;

      // Update raw energy data
      phaseEnergyChart.data.datasets[0].data[0] = prefillRaw != null ? prefillRaw : 0;
      phaseEnergyChart.data.datasets[1].data[0] = decodeRaw != null ? decodeRaw : 0;

      // Update active energy data
      phaseEnergyChart.data.datasets[0].data[1] = prefillActive != null ? prefillActive : 0;
      phaseEnergyChart.data.datasets[1].data[1] = decodeActive != null ? decodeActive : 0;

      phaseEnergyChart.update();
    }

    function initPhaseEnergyChart() {
      const canvas = document.getElementById('phaseEnergyChart');
      if (!canvas || !window.Chart) return;

      const ctx = canvas.getContext('2d');
      phaseEnergyChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: ['Raw', 'Active'],
          datasets: [
            {
              label: 'Prefill (Wh)',
              data: [0, 0],
              backgroundColor: 'rgba(129, 140, 248, 0.9)',
              borderRadius: 4,
              barThickness: 20,
            },
            {
              label: 'Decode (Wh)',
              data: [0, 0],
              backgroundColor: 'rgba(248, 113, 113, 0.9)',
              borderRadius: 4,
              barThickness: 20,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              stacked: false,
              ticks: { color: '#e5e7eb' },
              title: { display: true, text: 'Phase / Metric', color: '#9ca3af' },
            },
            y: {
              beginAtZero: true,
              ticks: { color: '#e5e7eb' },
              title: { display: true, text: 'Wh', color: '#9ca3af' },
            },
          },
          plugins: {
            legend: {
              labels: { color: '#e5e7eb' },
            },
          },
        },
      });
    }

    function initHfBenchmarkChart() {
      const canvas = document.getElementById('hfBenchmarkChartCanvas');
      if (!canvas || !window.Chart) return;

      const ctx = canvas.getContext('2d');
      hfBenchmarkChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Estimated Wh per run (baseline vs reference models)',
              data: [],
              backgroundColor: [
                'rgba(52, 211, 153, 0.9)', // Baseline
                'rgba(129, 140, 248, 0.9)',
                'rgba(251, 191, 36, 0.9)',
                'rgba(248, 113, 113, 0.9)',
                'rgba(96, 165, 250, 0.9)',
                'rgba(236, 72, 153, 0.9)',
              ],
              borderRadius: 4,
              barThickness: 26,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            x: {
              ticks: { color: '#e5e7eb', maxRotation: 45, minRotation: 0 },
              title: { display: true, text: 'Benchmark', color: '#9ca3af' },
            },
            y: {
              ticks: { color: '#e5e7eb' },
              title: { display: true, text: 'Wh per run (estimated)', color: '#9ca3af' },
            },
          },
          plugins: {
            legend: {
              display: true,
              labels: { color: '#e5e7eb' },
            },
            tooltip: {
              callbacks: {
                label: function (ctx) {
                  const val = ctx.parsed.y;
                  return `${ctx.label}: ${val.toFixed(6)} Wh`;
                },
              },
            },
          },
        },
      });
    }

    function initEnergyChart() {
      const canvas = document.getElementById('energyChart');
      if (!canvas || !window.Chart) return;

      const ctx = canvas.getContext('2d');
      energyChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Total Energy (Wh)',
              data: [],
              borderColor: 'rgba(96, 165, 250, 1)',
              backgroundColor: 'rgba(96, 165, 250, 0.2)',
              tension: 0.3,
            },
            {
              label: 'Intensity (Wh / 1K output tokens)',
              data: [],
              borderColor: 'rgba(52, 211, 153, 1)',
              backgroundColor: 'rgba(52, 211, 153, 0.2)',
              tension: 0.3,
              yAxisID: 'y1',
            },
            {
              label: 'RAPL Wh / 1K output tokens',
              data: [],
              borderColor: 'rgba(248, 113, 113, 1)',
              backgroundColor: 'rgba(248, 113, 113, 0.2)',
              borderDash: [4, 4],
              tension: 0.3,
              yAxisID: 'y1',
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: {
              ticks: { color: '#e5e7eb' },
            },
            y: {
              position: 'left',
              ticks: { color: '#e5e7eb' },
              title: { display: true, text: 'Wh', color: '#9ca3af' },
            },
            y1: {
              position: 'right',
              grid: { drawOnChartArea: false },
              ticks: { color: '#e5e7eb' },
              title: { display: true, text: 'Wh / 1K tokens', color: '#9ca3af' },
            },
          },
          plugins: {
            legend: {
              labels: { color: '#e5e7eb' },
            },
          },
        },
      });
    }

    function initPrefillDecodeChart() {
      const canvas = document.getElementById('prefillDecodeChart');
      if (!canvas || !window.Chart) return;

      const ctx = canvas.getContext('2d');
      prefillDecodeChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Prefill (Wh)',
              data: [],
              borderColor: 'rgba(129, 140, 248, 1)',
              backgroundColor: 'rgba(129, 140, 248, 0.15)',
              tension: 0.25,
              fill: false,
            },
            {
              label: 'Decode (Wh)',
              data: [],
              borderColor: 'rgba(248, 113, 113, 1)',
              backgroundColor: 'rgba(248, 113, 113, 0.15)',
              tension: 0.25,
              fill: false,
            },
            {
              label: 'Total (Wh)',
              data: [],
              borderColor: 'rgba(52, 211, 153, 1)',
              backgroundColor: 'rgba(52, 211, 153, 0.15)',
              tension: 0.25,
              fill: false,
            },
          ],
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          scales: {
            x: {
              ticks: { color: '#e5e7eb' },
              title: { display: true, text: 'Run', color: '#9ca3af' },
            },
            y: {
              ticks: { color: '#e5e7eb' },
              title: { display: true, text: 'Wh', color: '#9ca3af' },
            },
          },
          plugins: {
            legend: {
              labels: { color: '#e5e7eb' },
            },
          },
        },
      });
    }

    function analyzeModificationImpact(data) {
      const modInfo = data.modification_info;
      const energyMetrics = data.energy_metrics;

      let impactText = '';

      if (modInfo.injection_overhead > 0) {
        const totalTokens = data.basic_metrics ? data.basic_metrics.total_tokens : null;
        const measuredWh = data.live_power_metrics && data.live_power_metrics.measured_wh ? data.live_power_metrics.measured_wh : null;
        const baseWh = measuredWh !== null ? measuredWh : energyMetrics.watt_hours_consumed;
        let energyOverhead = null;
        if (totalTokens && totalTokens > 0) {
          energyOverhead = baseWh * (modInfo.injection_overhead / totalTokens);
        }
        if (energyOverhead !== null) {
          impactText += `Prompt injection added ${modInfo.injection_overhead} tokens, which we estimate account for ~${energyOverhead.toFixed(6)} Wh of this run's energy. `;
        } else {
          impactText += `Prompt injection added ${modInfo.injection_overhead} tokens (energy impact estimate unavailable). `;
        }
      }

      if (modInfo.tool_integration_applied && modInfo.tool_integration_applied.total_tokens_added > 0) {
        impactText += `Tool integration added ${modInfo.tool_integration_applied.total_tokens_added} tokens from tool outputs. `;
      }

      if (!impactText) {
        impactText = 'No significant modifications detected.';
      }

      if (modificationImpact) {
        modificationImpact.textContent = impactText;
      }
    }

    async function updateSessionSummary() {
      try {
        const r = await fetch('/api/session-summary');
        const summary = await r.json();

        if (summary.error) return;

        sessionEnergy.textContent = `${summary.total_energy_wh.toFixed(4)} Wh`;
        sessionCarbon.textContent = `${summary.total_carbon_gco2.toFixed(2)} gCO2`;
        sessionIntensity.textContent = `${summary.average_energy_per_1000_tokens.toFixed(4)} Wh/1K`;
        sessionTokens.textContent = summary.total_tokens;
        if (summary.rapl_session && typeof summary.rapl_session.measured_wh === 'number') {
          sessionRaplEnergy.textContent = `${summary.rapl_session.measured_wh.toFixed(6)} Wh`;
        }
      } catch (e) {
        console.error('Failed to update session summary:', e);
      }
    }

    function clearAllResults() {
      responseOutput.textContent = 'Run a test to see the model response here.';
      if (testEnergy) testEnergy.textContent = '0.00 Wh';
      if (testEnergyBar) testEnergyBar.style.width = '0%';
      if (efficiencyScore) efficiencyScore.textContent = '0.00';
      if (carbonImpact) carbonImpact.textContent = '0.00 gCO2';

      if (kpiEnergyWh) kpiEnergyWh.textContent = '-';
      if (kpiCarbonG) kpiCarbonG.textContent = '-';
      if (kpiEffBenchmark) kpiEffBenchmark.textContent = '-';
      if (kpiEffEllm) kpiEffEllm.textContent = '-';
      if (kpiEffMeff) kpiEffMeff.textContent = '-';
      if (kpiLatency) kpiLatency.textContent = '-';
      if (kpiTokensPerSec) kpiTokensPerSec.textContent = '-';
      if (kpiTtft) kpiTtft.textContent = '-';

      // Clear phase energy chart
      if (phaseEnergyChart) {
        phaseEnergyChart.data.datasets[0].data = [0, 0];
        phaseEnergyChart.data.datasets[1].data = [0, 0];
        phaseEnergyChart.update();
      }

      inThinking = false;
      answerStarted = false;

      resultStrategy.textContent = '-';
      resultTokens.textContent = '-';
      resultLatency.textContent = '-';
      resultTokensPerSec.textContent = '-';

      // Clear token breakdown
      if (inputTokens) inputTokens.textContent = '-';
      if (outputTokens) outputTokens.textContent = '-';
      if (injectionTokens) injectionTokens.textContent = '-';
      if (toolTokens) toolTokens.textContent = '-';
      tokenAnalysisNotes.textContent = 'Run a test to see detailed token breakdown.';
      const thinkEl = document.getElementById('thinkingTokensVal');
      if (thinkEl) thinkEl.textContent = '-';

      if (modificationImpact) {
        modificationImpact.textContent = 'Run a test to see energy impact analysis.';
      }

      // Clear chart
      energyHistory = [];
      if (mainResultsChart) {
        mainResultsChart.data.labels = [];
        mainResultsChart.data.datasets = [];
        mainResultsChart.update();
      }
    }

    async function exportSessionData() {
      try {
        const r = await fetch('/api/export-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filepath: 'energy_test_session.json' })
        });

        if (r.ok) {
          alert('Session data exported to energy_test_session.json');
        } else {
          alert('Export failed');
        }
      } catch (e) {
        alert('Export error: ' + e.message);
      }
    }

    function openCliModal() {
      if (cliModal) cliModal.classList.remove('hidden');
    }

    function closeCliModal() {
      if (cliModal) cliModal.classList.add('hidden');
    }

    function appendCliLog(line) {
      if (!cliLog) return;
      const div = document.createElement('div');
      div.textContent = line;
      cliLog.appendChild(div);
      cliLog.scrollTop = cliLog.scrollHeight;
    }

    function startGenerationProgress() {
      _genStartMs = Date.now();
      _genSpinIdx = 0;
      _genProgressEl = document.createElement('div');
      _genProgressEl.textContent = 'output generation in progress 00:00';
      if (cliLog) {
        cliLog.appendChild(_genProgressEl);
        cliLog.scrollTop = cliLog.scrollHeight;
      }
      const spins = ['|', '/', '-', '\\'];
      _genTimer = setInterval(() => {
        const elapsed = Date.now() - _genStartMs;
        const s = Math.floor(elapsed / 1000);
        const m = Math.floor(s / 60);
        const rr = String(s % 60).padStart(2, '0');
        const sp = spins[_genSpinIdx % spins.length];
        _genSpinIdx++;
        if (_genProgressEl) {
          _genProgressEl.textContent = `output generation in progress ${sp} ${m}:${rr}`;
        }
      }, 200);
    }

    function stopGenerationProgress(silent = false) {
      if (_genTimer) {
        clearInterval(_genTimer);
        _genTimer = null;
      }
      if (_genProgressEl && !silent) {
        const elapsed = Date.now() - _genStartMs;
        const s = Math.floor(elapsed / 1000);
        const m = Math.floor(s / 60);
        const rr = String(s % 60).padStart(2, '0');
        _genProgressEl.textContent = `output generation complete in ${m}:${rr}`;
      }
      _genProgressEl = null;
    }

    function setupWebSocket() {
      // Basic WebSocket setup for the energy test backend.
      try {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws`;

        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          if (connectionStatus) {
            connectionStatus.textContent = 'Connected';
            connectionStatus.className = 'px-4 py-2 rounded-full bg-green-100 text-green-700';
          }
          appendCliLog('‚úÖ WebSocket connected');
        };

        ws.onclose = (event) => {
          appendCliLog(`‚ö†Ô∏è WebSocket closed (code=${event.code}).`);
          if (connectionStatus) {
            connectionStatus.textContent = 'Disconnected';
            connectionStatus.className = 'px-4 py-2 rounded-full bg-red-100 text-red-700';
          }
        };

        ws.onerror = (event) => {
          console.error('WebSocket error:', event);
          appendCliLog('‚ùå WebSocket error ‚Äì check backend logs.');
        };

        ws.onmessage = (event) => {
          // Keep handling minimal here; existing handlers like
          // handleTestCompletion expect structured JSON messages from the
          // backend. We route full messages through that path when they
          // indicate completion, and log others to the CLI panel.
          try {
            const data = JSON.parse(event.data);

            if (typeof data.log === 'string') {
              appendCliLog(data.log);
              return;
            }

            if (typeof data.token === 'string') {
              if (data.token === '[DONE]' && data.done) {
                handleTestCompletion(data);
                return;
              }

              if (responseOutput) {
                responseOutput.textContent += data.token;
              }
              return;
            }

            if (data.error) {
              appendCliLog(`‚ùå ${data.error}`);
              if (data.done) {
                handleTestCompletion(data);
              }
              return;
            }

            if (data.done) {
              handleTestCompletion(data.payload || data);
              return;
            }

            appendCliLog(`[WS] ${event.data}`);
          } catch (e) {
            appendCliLog(`[WS raw] ${event.data}`);
          }
        };
      } catch (e) {
        console.error('Failed to setup WebSocket:', e);
        appendCliLog(`‚ùå Failed to setup WebSocket: ${e && e.message ? e.message : e}`);
      }
    }

    async function init() {
      // Load all data
      await loadModels();
      await loadHfBenchmarks();
      await loadBenchmarks();
      await loadSystemPrompts();
      await loadEmissionsData();

      await updateSessionSummary();

      // Setup UI
      setupWebSocket();
      initPhaseEnergyChart();
      initHfBenchmarkChart();
      initMainResultsChart();
      initPrefillDecodeChart();
      renderRaplBatchTable();

      // Check connection
      if (ws && ws.readyState === WebSocket.OPEN && connectionStatus) {
        connectionStatus.textContent = 'Connected';
        connectionStatus.className = 'px-4 py-2 rounded-full bg-green-100 text-green-700';
      }
    }

    // Call init to start everything
    init();
  </script>
</body>

</html>