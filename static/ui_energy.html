<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Energy Testing Lab - LLM Behavior Lab</title>
  <script src="/static/tailwind.min.js"></script>
  <script src="/static/chart.min.js"></script>
  <style>
    /* Modern Dark Dashboard Theme */
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --secondary: #8b5cf6;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --bg-dark: #0f172a;
      --bg-darker: #020617;
      --bg-card: #1e293b;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --border: #334155;
    }

    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--bg-darker) 0%, var(--bg-dark) 100%);
      color: var(--text-primary);
      min-height: 100vh;
    }

    .dashboard-card {
      background: var(--bg-card);
      border-radius: 16px;
      border: 1px solid var(--border);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }

    .dashboard-card:hover {
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
      border-color: var(--primary);
    }

    .nav-button {
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(10px);
      border: 2px solid transparent;
      border-radius: 16px;
      padding: 1rem 1.5rem;
      color: var(--text-secondary);
      font-weight: 600;
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 1px rgba(255, 255, 255, 0.1);
    }

    .nav-button::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, #6366f1, #8b5cf6, #ec4899, #f59e0b);
      background-size: 300% 300%;
      border-radius: 16px;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: -1;
    }

    .nav-button::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(99, 102, 241, 0.3), transparent);
      transition: left 0.5s;
    }

    .nav-button:hover::after {
      left: 100%;
    }

    .nav-button:hover {
      color: var(--text-primary);
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4), inset 0 1px 1px rgba(255, 255, 255, 0.2);
    }

    .nav-button.active {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.2) 0%, rgba(139, 92, 246, 0.2) 100%);
      color: white;
      box-shadow: 0 8px 30px rgba(99, 102, 241, 0.6), 0 0 40px rgba(99, 102, 241, 0.3), inset 0 1px 1px rgba(255, 255, 255, 0.2);
    }

    .nav-button.active::before {
      opacity: 1;
      animation: borderGlow 3s linear infinite;
    }

    @keyframes borderGlow {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    .metric-card {
      background: linear-gradient(135deg, var(--bg-card) 0%, #2d3748 100%);
      border-radius: 12px;
      padding: 1.5rem;
      border: 1px solid var(--border);
      transition: all 0.3s ease;
    }

    .metric-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
    }

    .metric-value {
      font-size: 2rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(99, 102, 241, 0.5);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
    }

    .section-content {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    .section-content.active {
      display: block;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .glow {
      box-shadow: 0 0 20px rgba(99, 102, 241, 0.5);
    }

    input,
    textarea,
    select {
      background: var(--bg-darker) !important;
      border: 1px solid var(--border) !important;
      color: var(--text-primary) !important;
      border-radius: 8px;
      padding: 0.75rem;
      transition: all 0.3s ease;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: var(--primary) !important;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
      background: var(--bg-dark) !important;
    }

    input::placeholder,
    textarea::placeholder {
      color: var(--text-secondary);
      opacity: 0.6;
    }

    /* Ensure select options are also dark */
    select option {
      background: var(--bg-darker);
      color: var(--text-primary);
    }

    /* Fix for number input spinners */
    input[type="number"] {
      -moz-appearance: textfield;
    }

    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      opacity: 0.5;
    }

    /* Checkbox styling for dark mode */
    input[type="checkbox"] {
      appearance: none;
      -webkit-appearance: none;
      width: 1.25rem;
      height: 1.25rem;
      border: 2px solid var(--border) !important;
      border-radius: 4px;
      background: var(--bg-darker) !important;
      cursor: pointer;
      position: relative;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    input[type="checkbox"]:hover {
      border-color: var(--primary) !important;
      background: var(--bg-dark) !important;
    }

    input[type="checkbox"]:checked {
      background: var(--primary) !important;
      border-color: var(--primary) !important;
    }

    input[type="checkbox"]:checked::after {
      content: '';
      position: absolute;
      left: 4px;
      top: 1px;
      width: 5px;
      height: 10px;
      border: solid white;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }

    input[type="checkbox"]:focus {
      outline: none;
      border-color: var(--primary) !important;
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2) !important;
    }

    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-darker);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--primary);
    }
  </style>
</head>

<body class="p-6">
  <div class="max-w-7xl mx-auto">

    <!-- Header -->
    <div class="mb-8">
      <h1 class="text-4xl font-bold mb-2 bg-gradient-to-r from-indigo-400 to-purple-400 bg-clip-text text-transparent">
        ‚ö° LLM Energy Testing Lab
      </h1>
      <p class="text-slate-400">Measure real-world energy consumption and carbon footprint of LLM interactions</p>
    </div>

    <!-- Navigation Dashboard (Sticky) -->
    <div class="sticky top-0 z-40 bg-gradient-to-b from-slate-950 to-transparent pb-4 mb-8">
      <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4">
        <button class="nav-button active" onclick="toggleSection('prompt-model')" data-section="prompt-model">
          <div class="text-2xl mb-2">üéØ</div>
          <div class="text-sm">Prompt Model</div>
        </button>
        <button class="nav-button" onclick="toggleSection('middleware')" data-section="middleware">
          <div class="text-2xl mb-2">üß©</div>
          <div class="text-sm">Middleware</div>
        </button>
        <button class="nav-button" onclick="toggleSection('live-power')" data-section="live-power">
          <div class="text-2xl mb-2">‚öôÔ∏è</div>
          <div class="text-sm">Live Power</div>
        </button>
        <button class="nav-button" onclick="toggleSection('estimated')" data-section="estimated">
          <div class="text-2xl mb-2">üìä</div>
          <div class="text-sm">Estimated</div>
        </button>
        <button class="nav-button" onclick="toggleSection('response')" data-section="response">
          <div class="text-2xl mb-2">üí¨</div>
          <div class="text-sm">Response</div>
        </button>
        <button class="nav-button" onclick="toggleSection('results')" data-section="results">
          <div class="text-2xl mb-2">üìà</div>
          <div class="text-sm">Results</div>
        </button>
      </div>
    </div>

    <!-- Test Controls (Always Visible) -->
    <div class="dashboard-card p-4 mb-6 sticky top-4 z-30">
      <div class="flex flex-wrap items-center gap-4">
        <button id="runTest" class="btn-primary flex items-center gap-2">
          <span class="text-lg">‚ö°</span> Run Energy Test
        </button>

        <button id="stopTest" disabled class="btn bg-slate-700 text-slate-400 px-4 py-2 rounded-lg cursor-not-allowed">
          Stop
        </button>

        <div class="h-8 w-px bg-slate-600"></div>

        <label class="flex items-center gap-2 cursor-pointer">
          <input type="checkbox" id="enableLivePower" class="w-4 h-4 text-indigo-600 rounded">
          <span class="text-sm font-medium">Enable Live Power (RAPL)</span>
        </label>

        <div class="ml-auto flex gap-2">
          <button id="showLogs" class="text-slate-400 hover:text-white text-sm">üìã Logs</button>
          <button id="clearResults" class="text-slate-400 hover:text-red-400 text-sm">üóëÔ∏è Clear</button>
          <button id="exportData" class="text-slate-400 hover:text-indigo-400 text-sm">üíæ Export</button>
        </div>
      </div>
    </div>

    <!-- Section: Prompt Model -->
    <div id="section-prompt-model" class="section-content active">
      <div class="dashboard-card p-6 space-y-6">
        <h2 class="text-2xl font-bold flex items-center gap-2">
          <span>üéØ</span> Prompt Model
        </h2>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <label class="block text-sm font-semibold mb-2">Model Selection</label>
            <select id="modelSelect" class="w-full">
              <option>Loading models‚Ä¶</option>
            </select>
            <div id="modelInfo" class="mt-2 text-xs text-slate-400 hidden">
              <div class="flex items-center gap-2">
                <span>üìä Context Length:</span>
                <span id="modelContextLength" class="font-mono text-indigo-400">-</span>
              </div>
            </div>
          </div>
        </div>

        <div>
          <label class="block text-sm font-semibold mb-2">User Query</label>
          <textarea id="userPrompt" class="w-full h-32 resize-y font-mono text-sm"
            placeholder="Explain quantum computing in simple terms."></textarea>
          <div class="text-xs text-slate-500 mt-2 flex items-center">
            üí° This is your actual query - the only "original" tokens
          </div>
        </div>
      </div>
    </div>

    <!-- Section: Middleware -->
    <div id="section-middleware" class="section-content">
      <div class="dashboard-card p-6 space-y-6">
        <h2 class="text-2xl font-bold flex items-center gap-2">
          <span>üß©</span> Hidden Middleware
        </h2>

        <div class="bg-blue-900/30 border border-blue-700/50 rounded-lg p-4 text-sm">
          <strong>‚ö†Ô∏è Middleware Overhead:</strong> Each injection adds hidden tokens to your query
        </div>

        <!-- System Prompt -->
        <div class="space-y-4">
          <h3 class="text-lg font-semibold border-b border-slate-700 pb-2">Inputs (Prefill Stage)</h3>

          <div>
            <div class="flex justify-between items-center mb-2">
              <label class="text-sm font-semibold">System Prompt</label>
              <div class="flex gap-2">
                <select id="systemPromptSelect" class="text-xs p-1.5">
                  <option value="">Custom / empty</option>
                </select>
                <button id="clearSystemPromptBtn" class="text-xs text-red-400 hover:text-red-300 px-2">Clear</button>
              </div>
            </div>
            <textarea id="systemPromptText" class="w-full h-24 text-sm font-mono"
              placeholder="Optional system prompt or middleware instructions"></textarea>
          </div>

          <div>
            <div class="flex justify-between items-center mb-2">
              <label class="text-sm font-semibold">Conversation Context</label>
              <button id="injectConversationBtn" class="text-xs bg-indigo-600 hover:bg-indigo-700 px-3 py-1.5 rounded">
                Inject Last Turn
              </button>
            </div>
            <textarea id="conversationContextText" class="w-full h-24 text-sm font-mono"
              placeholder="Conversation context will be wrapped in <conversation_context> tags."></textarea>
          </div>

          <div id="injectionsContainer" class="space-y-3"></div>
          <button id="addInjectionBtn"
            class="w-full py-2 border-2 border-dashed border-slate-600 rounded-lg hover:border-indigo-500 transition-all flex items-center justify-center gap-2">
            <span>‚ûï</span> Add Prompt Injection
          </button>
        </div>

        <!-- Outputs -->
        <div class="space-y-4">
          <h3 class="text-lg font-semibold border-b border-slate-700 pb-2">Outputs (Decode Stage)</h3>
          <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <label class="flex items-center gap-3 cursor-pointer">
              <input type="checkbox" id="includeThinking" class="w-5 h-5">
              <span class="text-sm font-medium">Include Thinking</span>
            </label>

            <div>
              <div class="flex justify-between mb-2">
                <label class="text-sm font-medium">Temperature</label>
                <span id="tempValue" class="text-sm font-mono text-indigo-400">0.7</span>
              </div>
              <input type="range" id="temperature" min="0" max="1" step="0.1" value="0.7" class="w-full">
            </div>

            <div>
              <label class="block text-sm font-medium mb-2">Max Tokens</label>
              <input type="number" id="maxTokens" value="1000" class="w-full">
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Section: Live Power -->
    <div id="section-live-power" class="section-content">
      <div class="dashboard-card p-6 space-y-6">
        <h2 class="text-2xl font-bold flex items-center gap-2">
          <span>‚öôÔ∏è</span> Configure Live Power Tests
          <span class="text-xs bg-green-600 px-2 py-1 rounded-full">Linux Only</span>
        </h2>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div class="metric-card">
            <h4 class="text-sm font-bold mb-4 flex items-center gap-2">
              <span>üîÑ</span> Batch Testing
            </h4>
            <label class="block text-xs text-slate-400 mb-2">Number of Runs</label>
            <input type="number" id="raplBatchRuns" value="1" min="1" max="100" class="w-full">
          </div>

          <div class="metric-card">
            <h4 class="text-sm font-bold mb-4 flex items-center gap-2">
              <span>üé≤</span> Reproducibility
            </h4>
            <label class="block text-xs text-slate-400 mb-2">Seed (Optional)</label>
            <input type="number" id="seedInput" placeholder="Random" class="w-full">

            <div class="mt-4 pt-4 border-t border-slate-700">
              <div class="flex items-center justify-between">
                <div>
                  <label class="block text-xs text-slate-400 mb-1">Calibration</label>
                  <p class="text-[10px] text-slate-500" id="raplCalibrationStatus">Not run yet.</p>
                </div>
                <button id="runRaplCalibration" class="text-xs bg-slate-700 hover:bg-slate-600 px-3 py-1.5 rounded">
                  Run Calibration
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Section: Estimated Power -->
    <div id="section-estimated" class="section-content">
      <div class="dashboard-card p-6 space-y-6">
        <h2 class="text-2xl font-bold flex items-center gap-2">
          <span>üìä</span> Configure Estimated Power Tests
        </h2>

        <div class="bg-indigo-900/30 border border-indigo-700/50 rounded-xl p-4 flex justify-between items-center">
          <div>
            <h4 class="text-sm font-bold mb-1">Current Benchmark</h4>
            <p id="currentBenchmarkInfo" class="text-xs text-indigo-300 font-mono">-</p>
          </div>
          <button id="benchmarkInfoBtn" class="px-3 py-1.5 bg-indigo-600 hover:bg-indigo-700 rounded text-xs">View
            Details</button>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <label class="block text-sm font-semibold mb-2">Switch Benchmark</label>
            <div class="flex gap-2">
              <select id="benchmarkSwitcher" class="flex-1">
                <option>Loading benchmarks...</option>
              </select>
              <button id="switchBenchmarkBtn" class="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded" disabled>
                Apply
              </button>
            </div>
          </div>
        </div>

        <div class="border-t border-slate-700 pt-6">
          <h4 class="text-sm font-bold mb-4">Add Custom Benchmark</h4>
          <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
            <input type="text" id="customBenchmarkName" placeholder="Name (e.g. RTX 3080)" class="w-full">
            <input type="number" id="customBenchmarkWattHours" step="0.01" placeholder="Wh/1k tokens" class="w-full">
            <input type="text" id="customBenchmarkDesc" placeholder="Description" class="w-full">
            <button id="addCustomBenchmarkBtn"
              class="px-4 py-2 bg-indigo-600 hover:bg-indigo-700 rounded whitespace-nowrap">
              Add
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Section: Response -->
    <div id="section-response" class="section-content">
      <div class="dashboard-card p-6">
        <h2 class="text-2xl font-bold flex items-center gap-2 mb-4">
          <span>üí¨</span> Response Output
        </h2>
        <div id="responseOutput"
          class="bg-slate-900 p-6 rounded-xl border border-slate-700 min-h-[200px] font-mono text-sm whitespace-pre-wrap">
          Run a test to see the model response here.
        </div>
      </div>
    </div>

    <!-- Section: Results -->
    <div id="section-results" class="section-content">
      <div class="space-y-6">

        <!-- Token Analysis -->
        <div class="dashboard-card p-6">
          <h2 class="text-2xl font-bold flex items-center gap-2 mb-6">
            <span>üìä</span> Token Analysis
          </h2>

          <div style="height: 120px; position: relative; margin-bottom: 2rem;">
            <canvas id="tokenBreakdownChart"></canvas>
          </div>

          <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
            <div class="metric-card text-center">
              <div class="text-xs text-slate-400 mb-1">Input</div>
              <div id="inputTokensVal" class="metric-value">-</div>
            </div>
            <div class="metric-card text-center">
              <div class="text-xs text-slate-400 mb-1">Overhead</div>
              <div id="overheadTokensVal" class="metric-value"
                style="background: linear-gradient(135deg, #f59e0b, #d97706); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                -</div>
            </div>
            <div class="metric-card text-center">
              <div class="text-xs text-slate-400 mb-1">Thinking</div>
              <div id="thinkingTokensVal" class="metric-value"
                style="background: linear-gradient(135deg, #a855f7, #9333ea); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                -</div>
            </div>
            <div class="metric-card text-center">
              <div class="text-xs text-slate-400 mb-1">Output</div>
              <div id="outputTokensVal" class="metric-value"
                style="background: linear-gradient(135deg, #3b82f6, #2563eb); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                -</div>
            </div>
          </div>

          <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
            <div class="metric-card">
              <div class="text-xs text-slate-400">Strategy</div>
              <div id="resultStrategy" class="font-medium truncate">-</div>
            </div>
            <div class="metric-card">
              <div class="text-xs text-slate-400">Total Tokens</div>
              <div id="resultTokens" class="font-medium">-</div>
            </div>
            <div class="metric-card">
              <div class="text-xs text-slate-400">Latency</div>
              <div id="resultLatency" class="font-medium">-</div>
            </div>
            <div class="metric-card">
              <div class="text-xs text-slate-400">Tokens/Sec</div>
              <div id="resultTokensPerSec" class="font-medium">-</div>
            </div>
          </div>
        </div>

        <!-- RAPL Results Dashboard -->
        <div class="dashboard-card p-6">
          <h2 class="text-2xl font-bold flex items-center gap-2 mb-6">
            <span>‚ö°</span> Live Power RAPL Results
          </h2>

          <div id="raplResultsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            <!-- RAPL results will be populated here as metric cards -->
          </div>
        </div>

        <!-- Results Overview -->
        <div class="dashboard-card p-6">
          <h2 class="text-2xl font-bold flex items-center gap-2 mb-6">
            <span>üìà</span> Results Overview
          </h2>

          <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
            <div class="metric-card text-center">
              <div class="metric-value text-4xl" id="efficiencyScore">0.00</div>
              <div class="text-xs font-bold text-slate-400 mt-2">Wh/1000 e-tokens</div>
              <div class="text-[10px] text-slate-500 mt-1">Energy Efficiency Score</div>
            </div>

            <div class="metric-card text-center">
              <div class="metric-value text-4xl" id="carbonImpact"
                style="background: linear-gradient(135deg, #10b981, #059669); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
                0.00</div>
              <div class="text-xs font-bold text-slate-400 mt-2">gCO2</div>
              <div class="text-[10px] text-slate-500 mt-1">Carbon Footprint</div>
            </div>

            <div class="metric-card">
              <div class="flex justify-between text-sm mb-2 font-medium">
                <span>Test Energy</span>
                <span id="testEnergy">0.00 Wh</span>
              </div>
              <div class="w-full bg-slate-800 rounded-full h-3 overflow-hidden">
                <div id="testEnergyBar" class="h-full rounded-full transition-all duration-1000"
                  style="width: 0%; background: linear-gradient(90deg, #10b981, #059669);"></div>
              </div>
            </div>
          </div>

          <div style="height: 200px; position: relative;">
            <canvas id="energyChart"></canvas>
          </div>
        </div>

      </div>
    </div>

    <!-- CLI Modal -->
    <div id="cliModal" class="fixed inset-0 hidden z-50">
      <div class="w-full h-full flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
        <div
          class="bg-slate-900 rounded-xl shadow-2xl w-full max-w-4xl border border-slate-700 flex flex-col max-h-[80vh]">
          <div class="flex items-center justify-between p-4 border-b border-slate-700">
            <h3 class="text-lg font-mono font-bold text-green-400 flex items-center gap-2">
              <span class="animate-pulse">_</span> Live Measurement Logs
            </h3>
            <button id="closeCliModalBtn" class="text-slate-400 hover:text-white">‚úï</button>
          </div>
          <div id="cliLog" class="p-4 overflow-auto font-mono text-xs text-slate-300 space-y-1 flex-1"></div>
        </div>
      </div>
    </div>

    <!-- Hidden elements for JS compatibility -->
    <div class="hidden">
      <div id="modificationImpact"></div>
      <div id="connectionStatus"></div>
      <div id="energyBenchmark"></div>
      <div id="injectionTokens"></div>
      <div id="toolTokens"></div>
      <div id="inputTokens"></div>
      <div id="outputTokens"></div>
      <div id="tokenAnalysisNotes"></div>
      <div id="prefillPer1kIn"></div>
      <div id="decodePer1kOut"></div>
      <div id="ewOutPer1k"></div>
      <div id="raplEfficiency"></div>
      <div id="powerBaseline"></div>
      <div id="powerActive"></div>
      <div id="powerMeasured"></div>
      <div id="prefillEnergy"></div>
      <div id="decodeEnergy"></div>
      <div id="sessionEnergy"></div>
      <div id="sessionCarbon"></div>
      <div id="sessionEfficiency"></div>
      <div id="sessionTokens"></div>
      <div id="sessionRaplEnergy"></div>
      <input type="number" id="raplCalibrationRuns" value="5" class="hidden">
      <input type="number" id="raplCalibrationWords" value="120" class="hidden">
      <input type="text" id="customBenchmarkSpecs" class="hidden">
    </div>

  </div>

  <script>
    // Section Navigation - Toggle multiple sections
    function toggleSection(sectionId) {
      const section = document.getElementById(`section-${sectionId}`);
      const button = document.querySelector(`[data-section="${sectionId}"]`);

      // Toggle section visibility
      section.classList.toggle('active');

      // Toggle button active state
      button.classList.toggle('active');
    }
  </script>
  <script>
    // DOM references
    const modelSelect = document.getElementById('modelSelect');

    const systemPromptSelect = document.getElementById('systemPromptSelect');
    const systemPromptText = document.getElementById('systemPromptText');
    const conversationContextText = document.getElementById('conversationContextText');
    const userPrompt = document.getElementById('userPrompt');
    const temperature = document.getElementById('temperature');
    const maxTokens = document.getElementById('maxTokens');
    const tempValue = document.getElementById('tempValue');
    const runTest = document.getElementById('runTest');
    const stopTest = document.getElementById('stopTest');
    const clearResults = document.getElementById('clearResults');
    const exportData = document.getElementById('exportData');
    const showLogs = document.getElementById('showLogs');
    const cliModal = document.getElementById('cliModal');
    const cliLog = document.getElementById('cliLog');
    const closeCliModalBtn = document.getElementById('closeCliModalBtn');
    let _genProgressEl = null;
    let _genTimer = null;
    let _genStartMs = 0;
    let _genSpinIdx = 0;

    // Benchmark controls
    const currentBenchmarkInfo = document.getElementById('currentBenchmarkInfo');
    const benchmarkInfoBtn = document.getElementById('benchmarkInfoBtn');
    const benchmarkSwitcher = document.getElementById('benchmarkSwitcher');
    const switchBenchmarkBtn = document.getElementById('switchBenchmarkBtn');
    const customBenchmarkName = document.getElementById('customBenchmarkName');
    const customBenchmarkWattHours = document.getElementById('customBenchmarkWattHours');
    const customBenchmarkDesc = document.getElementById('customBenchmarkDesc');
    const customBenchmarkSpecs = document.getElementById('customBenchmarkSpecs');
    const addCustomBenchmarkBtn = document.getElementById('addCustomBenchmarkBtn');
    const runRaplCalibration = document.getElementById('runRaplCalibration');
    const runRaplBatch = document.getElementById('runRaplBatch');
    const raplBatchTableBody = document.getElementById('raplBatchTableBody');

    // Token analysis elements
    const inputTokens = document.getElementById('inputTokens');
    const outputTokens = document.getElementById('outputTokens');
    const injectionTokens = document.getElementById('injectionTokens');
    const toolTokens = document.getElementById('toolTokens');
    const tokenAnalysisNotes = document.getElementById('tokenAnalysisNotes');

    // Results elements
    const sessionEnergy = document.getElementById('sessionEnergy');
    const sessionCarbon = document.getElementById('sessionCarbon');
    const sessionEfficiency = document.getElementById('sessionEfficiency');
    const sessionTokens = document.getElementById('sessionTokens');
    const sessionRaplEnergy = document.getElementById('sessionRaplEnergy');

    const testEnergy = document.getElementById('testEnergy');
    const testEnergyBar = document.getElementById('testEnergyBar');
    const efficiencyScore = document.getElementById('efficiencyScore');
    const carbonImpact = document.getElementById('carbonImpact');
    const raplEnergy = document.getElementById('raplEnergy');
    const raplEfficiency = document.getElementById('raplEfficiency');

    const resultStrategy = document.getElementById('resultStrategy');
    const resultTokens = document.getElementById('resultTokens');
    const resultLatency = document.getElementById('resultLatency');
    const resultTokensPerSec = document.getElementById('resultTokensPerSec');

    const modificationImpact = document.getElementById('modificationImpact');
    const responseOutput = document.getElementById('responseOutput');
    const connectionStatus = document.getElementById('connectionStatus');

    // State
    let ws = null;
    let energyHistory = [];
    let currentTestResults = null;
    let batchRunning = false;
    let batchStopRequested = false;
    let _raplBatchFirstDuration = null;
    let _raplLastBatchResult = null;
    let raplBatchSummaries = [];
    let systemPrompts = [];
    let inThinking = false;
    let answerStarted = false;

    function renderRaplBatchTable() {
      const container = document.getElementById('raplResultsContainer');
      if (!container) return;

      container.innerHTML = '';

      if (raplBatchSummaries.length === 0) {
        container.innerHTML = `
          <div class="col-span-full text-center text-slate-400 py-8">
            <div class="text-4xl mb-2">üìä</div>
            <div>No RAPL measurements yet. Run a test with Live Power enabled.</div>
          </div>
        `;
        return;
      }

      const sorted = raplBatchSummaries.slice().reverse();
      sorted.forEach(s => {
        const card = document.createElement('div');
        card.className = 'metric-card';
        card.innerHTML = `
          <div class="flex justify-between items-start mb-3">
            <div class="text-xs text-slate-400">${s.time}</div>
            <button data-id="${s.id}" class="text-red-400 hover:text-red-300 text-xs">‚úï</button>
          </div>
          <div class="space-y-2">
            <div>
              <div class="text-xs text-slate-500">Runs</div>
              <div class="text-lg font-bold">${s.runs}</div>
            </div>
            <div>
              <div class="text-xs text-slate-500">Mean Wh/1k e-tokens</div>
              <div class="text-2xl font-bold bg-gradient-to-r from-indigo-400 to-purple-400 bg-clip-text text-transparent">
                ${(s.meanWhPer1k ?? 0).toFixed(3)}
              </div>
            </div>
            <div class="grid grid-cols-2 gap-2 text-xs">
              <div>
                <div class="text-slate-500">Median</div>
                <div class="font-semibold">${(s.medianWhPer1k ?? 0).toFixed(3)}</div>
              </div>
              <div>
                <div class="text-slate-500">Std Dev</div>
                <div class="font-semibold">${(s.stdWhPer1k ?? 0).toFixed(3)}</div>
              </div>
              <div>
                <div class="text-slate-500">CV</div>
                <div class="font-semibold">${(s.cv ?? 0).toFixed(3)}</div>
              </div>
              <div>
                <div class="text-slate-500">Total Wh</div>
                <div class="font-semibold">${(s.meanTotalWh != null ? s.meanTotalWh.toFixed(6) : 'n/a')}</div>
              </div>
            </div>
          </div>
        `;
        container.appendChild(card);
      });

      // Re-attach listeners
      container.querySelectorAll('button[data-id]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const id = e.target.getAttribute('data-id');
          raplBatchSummaries = raplBatchSummaries.filter(x => x.id !== id);
          renderRaplBatchTable();
        });
      });
    }

    // Chart
    let energyChart = null;
    let prefillDecodeChart = null;

    // Initialize (called at bottom)

    async function loadModels() {
      console.log('üîÑ Attempting to load models...');
      try {
        const r = await fetch('/api/models');
        console.log('üì° Models API response status:', r.status);
        if (!r.ok) {
          const errorText = await r.text();
          console.error('‚ùå Models API request failed:', r.status, errorText);
          modelSelect.innerHTML = '<option>Error loading models (API failed)</option>';
          return;
        }
        const d = await r.json();
        console.log('‚úì Models API response data:', d);
        modelSelect.innerHTML = '';
        if (d.models && d.models.length > 0) {
          d.models.forEach(model => {
            const opt = document.createElement('option');
            opt.value = model;
            opt.textContent = model;
            modelSelect.appendChild(opt);
          });
          console.log('‚úì Models dropdown populated with', d.models.length, 'models');
          const preferred = (d.current && (d.current.instruct || d.current.base)) || null;
          if (preferred && d.models.includes(preferred)) {
            modelSelect.value = preferred;
          } else if (modelSelect.options.length > 0) {
            modelSelect.selectedIndex = 0;
          }
          // Load info for the selected model
          await loadModelInfo(modelSelect.value);
        } else {
          modelSelect.innerHTML = '<option>No models available</option>';
          console.log('‚ö†Ô∏è No models found in API response');
        }
      } catch (e) {
        console.error('‚ùå Failed to load models (JS error):', e);
        modelSelect.innerHTML = '<option>Error loading models (JS error)</option>';
      }
    }

    async function loadModelInfo(modelName) {
      if (!modelName || modelName.includes('Loading') || modelName.includes('Error') || modelName.includes('No models')) {
        document.getElementById('modelInfo').classList.add('hidden');
        return;
      }

      try {
        const r = await fetch(`/api/model-info/${encodeURIComponent(modelName)}`);
        if (r.ok) {
          const info = await r.json();
          const contextLength = info.context_length || 4096;
          document.getElementById('modelContextLength').textContent = contextLength.toLocaleString();
          document.getElementById('modelInfo').classList.remove('hidden');
          console.log(`‚úì Model ${modelName} context length: ${contextLength}`);
        } else {
          document.getElementById('modelInfo').classList.add('hidden');
          console.warn(`‚ö†Ô∏è Could not fetch info for model ${modelName}`);
        }
      } catch (e) {
        console.error(`‚ùå Error fetching model info for ${modelName}:`, e);
        document.getElementById('modelInfo').classList.add('hidden');
      }
    }

    // Update model info when model selection changes
    modelSelect.addEventListener('change', () => {
      loadModelInfo(modelSelect.value);
    });

    async function loadSystemPrompts() {
      try {
        const r = await fetch('/api/system-prompts');
        const d = await r.json();
        systemPrompts = Array.isArray(d.prompts) ? d.prompts : [];

        // Reset dropdown, keep the custom/empty option
        systemPromptSelect.innerHTML = '<option value="">Custom / empty</option>';

        systemPrompts.forEach(prompt => {
          const opt = document.createElement('option');
          opt.value = prompt.id;
          opt.textContent = prompt.name;
          systemPromptSelect.appendChild(opt);
        });
      } catch (e) {
        console.error('Failed to load system prompts:', e);
      }
    }

    async function loadBenchmarks() {
      console.log('üîÑ Attempting to load benchmarks...');
      try {
        const r = await fetch('/api/energy-benchmarks');
        if (!r.ok) throw new Error(`API Error: ${r.status}`);

        const d = await r.json();
        console.log('‚úì Benchmarks loaded:', d);

        if (benchmarkSwitcher) {
          benchmarkSwitcher.innerHTML = '';
          // Handle both array format and object with benchmarks property
          const benchmarks = Array.isArray(d) ? d : (d.benchmarks || []);

          benchmarks.forEach(b => {
            const opt = document.createElement('option');
            opt.value = b.name;
            opt.textContent = `${b.name} (${b.wh_per_1000_tokens || b.watt_hours_per_1000_tokens} Wh/1k)`;
            opt.dataset.desc = b.description || '';
            opt.dataset.wh = b.wh_per_1000_tokens || b.watt_hours_per_1000_tokens;
            benchmarkSwitcher.appendChild(opt);
          });

          // Set initial info
          updateBenchmarkInfo();
        }
      } catch (e) {
        console.error('‚ùå Failed to load benchmarks:', e);
        if (benchmarkSwitcher) benchmarkSwitcher.innerHTML = '<option>Error loading benchmarks</option>';
      }
    }

    function updateBenchmarkInfo() {
      if (!benchmarkSwitcher || !currentBenchmarkInfo) return;
      const selected = benchmarkSwitcher.options[benchmarkSwitcher.selectedIndex];
      if (selected) {
        currentBenchmarkInfo.textContent = `${selected.value}: ${selected.dataset.desc || ''}`;
      }
    }

    // Event Listeners for Benchmark Switching
    if (switchBenchmarkBtn) {
      switchBenchmarkBtn.addEventListener('click', () => {
        updateBenchmarkInfo();
        // Visual feedback
        const originalText = switchBenchmarkBtn.textContent;
        switchBenchmarkBtn.textContent = 'Applied!';
        switchBenchmarkBtn.classList.add('bg-green-600');
        setTimeout(() => {
          switchBenchmarkBtn.textContent = originalText;
          switchBenchmarkBtn.classList.remove('bg-green-600');
        }, 1000);
      });
    }

    if (benchmarkSwitcher) {
      benchmarkSwitcher.addEventListener('change', () => {
        if (switchBenchmarkBtn) switchBenchmarkBtn.disabled = false;
      });
    }



    function setupWebSocket() {
      const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
      ws = new WebSocket(`${wsProto}://${location.host}/ws`);

      ws.onopen = () => {
        if (connectionStatus) {
          connectionStatus.textContent = 'Connected';
          connectionStatus.className = 'px-4 py-2 rounded-full bg-green-100 text-green-700';
        }
      };

      ws.onclose = () => {
        if (connectionStatus) {
          connectionStatus.textContent = 'Disconnected';
          connectionStatus.className = 'px-4 py-2 rounded-full bg-red-100 text-red-700';
        }
      };

      ws.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        console.log('üì© WebSocket message received:', data);

        if (data.log) {
          console.log('üéØ ROUTING LOG:', data.log);
          appendCliLog(data.log);
        } else if (data.token && !data.done) {
          // Streaming token: update UI output only; suppress token logging in CLI
          const isThinking = data.thinking === true;
          if (isThinking) {
            if (!inThinking) {
              responseOutput.textContent += (responseOutput.textContent.endsWith('\n') ? '' : '\n') + 'Thinking:\n';
              inThinking = true;
            }
          } else {
            if (inThinking) {
              responseOutput.textContent += '</thinking>';
              inThinking = false;
            }
            if (!answerStarted) {
              responseOutput.textContent += (responseOutput.textContent.endsWith('\n') ? '' : '\n') + '\nAnswer:\n';
              answerStarted = true;
            }
          }

          responseOutput.textContent += data.token;
          if (!_genTimer) {
            startGenerationProgress();
          }
        } else if (data.done) {
          console.log('‚úîÔ∏è Test completion received');
          // Ensure closing tag if we ended inside thinking
          if (inThinking) {
            responseOutput.textContent += '</thinking>';
            inThinking = false;
          }
          stopGenerationProgress();
          await handleTestCompletion(data);
        } else if (data.error) {
          console.error('‚ùå Error from backend:', data.error);
          stopGenerationProgress(true);
          alert(`Error: ${data.error}`);
        } else {
          console.warn('‚ö†Ô∏è Unknown message type:', data);
        }
      };
    }

    function setupEventListeners() {
      temperature.addEventListener('input', () => tempValue.textContent = temperature.value);

      // Benchmark controls
      // Benchmark controls
      benchmarkInfoBtn.addEventListener('click', showBenchmarkInfo);
      switchBenchmarkBtn.addEventListener('click', switchBenchmark);
      addCustomBenchmarkBtn.addEventListener('click', addCustomBenchmark);
      if (runRaplCalibration) runRaplCalibration.addEventListener('click', runRaplCalibrationHandler);
      // runRaplBatch button removed (integrated into main run)

      // System prompt selection
      if (systemPromptSelect) {
        systemPromptSelect.addEventListener('change', () => {
          const id = systemPromptSelect.value;
          if (!id) {
            // Custom / empty
            return;
          }
          const found = systemPrompts.find(p => p.id === id);
          if (found && typeof found.content === 'string') {
            systemPromptText.value = found.content;
          }
        });
      }

      // Clear system prompt
      const clearSystemPromptBtn = document.getElementById('clearSystemPromptBtn');
      if (clearSystemPromptBtn) {
        clearSystemPromptBtn.addEventListener('click', () => {
          if (systemPromptSelect) systemPromptSelect.value = '';
          if (systemPromptText) systemPromptText.value = '';
        });
      }

      // Inject latest conversation into context
      const injectConversationBtn = document.getElementById('injectConversationBtn');
      if (injectConversationBtn && conversationContextText) {
        injectConversationBtn.addEventListener('click', () => {
          const userText = userPrompt.value.trim();
          const responseText = responseOutput.textContent.trim();
          if (!userText && !responseText) {
            return;
          }

          const blockLines = [];
          blockLines.push('<conversation_context>');
          if (userText) {
            blockLines.push('[User] ' + userText);
          }
          if (responseText) {
            blockLines.push('[Assistant] ' + responseText);
          }
          blockLines.push('</conversation_context>');

          const block = blockLines.join('\n');
          const existing = conversationContextText.value || '';
          // If this exact block is already present, do not append again
          if (existing.includes(block)) {
            return;
          }
          conversationContextText.value = existing.trim()
            ? (existing.trimEnd() + '\n\n' + block)
            : block;
        });
      }

      runTest.addEventListener('click', runEnergyTest);
      stopTest.addEventListener('click', stopEnergyTest);
      clearResults.addEventListener('click', clearAllResults);
      exportData.addEventListener('click', exportSessionData);
      showLogs.addEventListener('click', openCliModal);
      const runRaplCrossoverBtn = document.getElementById('runRaplCrossover');
      if (runRaplCrossoverBtn) runRaplCrossoverBtn.addEventListener('click', runRaplCrossoverHandler);
      closeCliModalBtn.addEventListener('click', closeCliModal);
    }

    function initChart() {
      const ctx = document.getElementById('energyChart').getContext('2d');
      energyChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Total Energy (Wh)',
              data: [],
              borderColor: 'rgb(59, 130, 246)', // Blue
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              yAxisID: 'y',
              tension: 0.1
            },
            {
              label: 'Intensity (Wh/1k e-tokens)',
              data: [],
              borderColor: 'rgb(147, 51, 234)', // Purple
              backgroundColor: 'rgba(147, 51, 234, 0.15)',
              yAxisID: 'y1',
              tension: 0.1
            }
          ]
        },
        options: {
          responsive: true,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          scales: {
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: { display: true, text: 'Total Energy (Wh)' }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: { display: true, text: 'Wh / 1000 Output Tokens' },
              grid: {
                drawOnChartArea: false, // only want the grid lines for one axis to show up
              },
            },
            x: {
              title: { display: true, text: 'Test Run' }
            }
          }
        }
      });
    }

    function initPrefillDecodeChart() {
      const el = document.getElementById('prefillDecodeChart');
      if (!el) return;
      const ctx = el.getContext('2d');
      prefillDecodeChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Prefill Wh',
              data: [],
              borderColor: 'rgb(16, 185, 129)', // Emerald
              backgroundColor: 'rgba(16, 185, 129, 0.12)',
              yAxisID: 'y',
              tension: 0.1
            },
            {
              label: 'Decode Wh',
              data: [],
              borderColor: 'rgb(59, 130, 246)', // Blue
              backgroundColor: 'rgba(59, 130, 246, 0.12)',
              yAxisID: 'y',
              tension: 0.1
            }
          ]
        },
        options: {
          responsive: true,
          interaction: { mode: 'index', intersect: false },
          scales: {
            y: { type: 'linear', display: true, position: 'left', title: { display: true, text: 'Energy (Wh)' } },
            x: { title: { display: true, text: 'Test Run' } }
          }
        }
      });
    }

    async function showBenchmarkInfo() {
      try {
        const r = await fetch('/api/benchmark-info');
        const data = await r.json();

        let info = 'Benchmark Information:\n\n';

        if (data.benchmarks) {
          info += 'Available Benchmarks:\n';
          data.benchmarks.forEach(b => {
            info += `‚Ä¢ ${b.name}: ${b.watt_hours_per_1000_tokens} Wh/1000 tokens\n`;
            info += `  ${b.description}\n`;
            if (b.source !== 'Custom') info += `  Source: ${b.source}\n`;
            if (b.hardware_specs) info += `  Hardware: ${b.hardware_specs}\n`;
            info += '\n';
          });
        }

        if (data.co2_info) {
          info += `CO2 Conversion: ${data.co2_info.global_average_gco2_per_kwh} gCO2/kWh\n`;
          info += `Source: ${data.co2_info.source}\n`;
          info += `Calculation: ${data.co2_info.calculation}\n\n`;
        }

        if (data.benchmark_sources) {
          info += 'Detailed Benchmark Sources:\n';
          Object.entries(data.benchmark_sources).forEach(([name, details]) => {
            info += `${name}:\n`;
            Object.entries(details).forEach(([key, value]) => {
              info += `  ${key}: ${value}\n`;
            });
            info += '\n';
          });
        }

        alert(info);
      } catch (e) {
        console.error('Failed to load benchmark info:', e);
        alert('Error loading benchmark information');
      }
    }

    async function switchBenchmark() {
      const selectedBenchmark = benchmarkSwitcher.value;
      if (!selectedBenchmark) {
        alert('Please select a benchmark');
        return;
      }

      try {
        switchBenchmarkBtn.disabled = true;
        switchBenchmarkBtn.textContent = 'Recalculating...';

        const r = await fetch('/api/switch-benchmark', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ benchmark_name: selectedBenchmark })
        });

        if (r.ok) {
          const result = await r.json();
          // Update the UI with recalculated values
          updateSessionWithRecalculatedData(result);

          alert(`Successfully switched to ${result.benchmark_used} benchmark`);
        } else {
          const error = await r.json();
          alert(`Error switching benchmark: ${error.detail || 'Unknown error'}`);
        }
      } catch (e) {
        console.error('Failed to switch benchmark:', e);
        alert('Error switching benchmark');
      } finally {
        switchBenchmarkBtn.disabled = false;
        switchBenchmarkBtn.textContent = 'Recalculate with Selected Benchmark';
      }
    }

    async function addCustomBenchmark() {
      const name = customBenchmarkName.value.trim();
      const wattHours = parseFloat(customBenchmarkWattHours.value);
      const desc = customBenchmarkDesc.value.trim();
      const specs = customBenchmarkSpecs.value.trim();

      if (!name || !desc || isNaN(wattHours) || wattHours <= 0) {
        alert('Please fill in all required fields with valid values');
        return;
      }

      try {
        addCustomBenchmarkBtn.disabled = true;
        addCustomBenchmarkBtn.textContent = 'Adding...';

        const r = await fetch('/api/add-custom-benchmark', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: name,
            description: desc,
            watt_hours_per_1000_tokens: wattHours,
            hardware_specs: specs || undefined
          })
        });

        if (r.ok) {
          const result = await r.json();
          alert(result.message);

          // Clear form and reload benchmark options
          customBenchmarkName.value = '';
          customBenchmarkWattHours.value = '';
          customBenchmarkDesc.value = '';
          customBenchmarkSpecs.value = '';

          await loadBenchmarks();
          await loadBenchmarks(); // Refresh benchmarks
          benchmarkSwitcher.value = name; // Select the new benchmark
          updateBenchmarkInfo();
        } else {
          const error = await r.json();
          alert(`Error adding benchmark: ${error.detail || 'Unknown error'}`);
        }
      } catch (e) {
        console.error('Failed to add custom benchmark:', e);
        alert('Error adding custom benchmark');
      } finally {
        addCustomBenchmarkBtn.disabled = false;
        addCustomBenchmarkBtn.textContent = 'Add Custom Benchmark';
      }
    }

    async function runRaplCalibrationHandler() {
      const runsInput = document.getElementById('raplCalibrationRuns');
      const statusEl = document.getElementById('raplCalibrationStatus');
      const statsContainer = document.getElementById('raplCalibrationStats');
      const runs = parseInt(runsInput.value, 10) || 1;
      const targetWordsInput = document.getElementById('raplCalibrationWords');
      const target_words = parseInt(targetWordsInput.value, 10) || 120;

      const model = modelSelect.value;
      const includeThinking = document.getElementById('includeThinking').checked;
      if (!model) {
        alert('Please select a model before running RAPL calibration.');
        return;
      }

      try {
        if (statusEl) statusEl.textContent = `Running ${runs} RAPL calibration run(s)‚Ä¶ this may take a while.`;
        runRaplCalibration.disabled = true;
        // Open CLI modal and log start
        if (cliModal && cliLog) {
          cliModal.classList.remove('hidden');
          cliLog.textContent += `\n[CALIBRATION] Starting ${runs} RAPL calibration run(s) for ${model}‚Ä¶`;
          cliLog.scrollTop = cliLog.scrollHeight;
        }

        const r = await fetch('/api/rapl-calibrate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ runs, model_name: model, include_thinking: includeThinking, target_words })
        });

        if (!r.ok) {
          const err = await r.json().catch(() => ({}));
          throw new Error(err.detail || 'Calibration failed');
        }

        const data = await r.json();
        const s = data.stats || {};
        const b = data.benchmark || {};

        const meanEl = document.getElementById('raplCalMean');
        const medEl = document.getElementById('raplCalMedian');
        const stdEl = document.getElementById('raplCalStd');
        const p5El = document.getElementById('raplCalP5');
        const p95El = document.getElementById('raplCalP95');
        const cvEl = document.getElementById('raplCalCv');
        const nameEl = document.getElementById('raplCalBenchmarkName');

        if (meanEl) meanEl.textContent = (s.mean ?? 0).toFixed(6);
        if (medEl) medEl.textContent = (s.median ?? 0).toFixed(6);
        if (stdEl) stdEl.textContent = (s.std ?? 0).toFixed(6);
        if (p5El) p5El.textContent = (s.p5 ?? 0).toFixed(6);
        if (p95El) p95El.textContent = (s.p95 ?? 0).toFixed(6);
        if (cvEl) cvEl.textContent = s.cv != null ? s.cv.toFixed(2) : '-';
        if (nameEl) nameEl.textContent = b.name || '-';

        if (statsContainer) statsContainer.classList.remove('hidden');
        if (statusEl) statusEl.textContent = `RAPL calibration complete. Benchmark '${b.name || ''}' is now available.`;

        if (cliLog) {
          cliLog.textContent += `\n[CALIBRATION] Complete. Benchmark '${b.name || ''}' median=${(s.median ?? 0).toFixed(6)} Wh/1K.`;
          cliLog.scrollTop = cliLog.scrollHeight;
        }

        // Refresh benchmark lists and auto-select the new calibrated benchmark
        await loadBenchmarks();
        await loadBenchmarks();
        benchmarkSwitcher.value = b.name;
        updateBenchmarkInfo();
        if (energyBenchmark) energyBenchmark.value = b.name;
      } catch (e) {
        console.error('RAPL calibration failed:', e);
        if (statusEl) statusEl.textContent = 'RAPL calibration failed.';
        if (cliLog) {
          cliLog.textContent += `\n[CALIBRATION] Failed: ${e && e.message ? e.message : e}`;
          cliLog.scrollTop = cliLog.scrollHeight;
        }
      } finally {
        runRaplCalibration.disabled = false;
      }
    }

    // Build payload from current UI (system prompt + conversation context + query + injections + settings)
    function buildEnergyPayload(forceRapl = false) {
      const userQuery = userPrompt.value.trim();
      if (!userQuery) {
        throw new Error('Please enter a user query');
      }

      // Get raw components
      const baseSystem = systemPromptText.value.trim();
      const convoContext = conversationContextText ? conversationContextText.value.trim() : '';

      // Get structured injections
      const userInjections = getInjections().map(inj => ({
        description: inj.description,
        content: inj.content
      }));

      const payload = {
        // New structured fields for backend composition
        system_prompt: baseSystem,
        user_prompt: userQuery,
        conversation_context: convoContext,
        injections: userInjections,

        // Legacy fields (optional, but good to keep for now)
        system: baseSystem,
        user: userQuery,

        model_name: modelSelect.value,
        strategy_name: 'custom_injection',
        energy_benchmark: benchmarkSwitcher.value || 'conservative_estimate',
        injection_type: userInjections.length > 0 ? 'user_defined' : 'none',

        temp: parseFloat(temperature.value),
        max_tokens: parseInt(maxTokens.value),
        seed: document.getElementById('seedInput').value ? parseInt(document.getElementById('seedInput').value) : null,
        enable_live_power_monitoring: forceRapl ? true : (document.getElementById('enableLivePower')?.checked === true),
        include_thinking: (document.getElementById('includeThinking')?.checked === true)
      };

      return payload;
    }

    function updateSessionWithRecalculatedData(recalculatedData) {
      // Update session summary display
      sessionEnergy.textContent = `${recalculatedData.total_energy_wh.toFixed(4)} Wh`;
      sessionCarbon.textContent = `${recalculatedData.total_carbon_gco2.toFixed(2)} gCO2`;
      sessionEfficiency.textContent = `${recalculatedData.average_energy_per_1000_tokens.toFixed(4)} Wh/1K`;
      sessionTokens.textContent = recalculatedData.total_tokens;
      if (sessionRaplEnergy && recalculatedData.session_summary?.rapl_session) {
        sessionRaplEnergy.textContent = `${recalculatedData.session_summary.rapl_session.toFixed(6)} Wh`;
      }

      // If we have current test results, update the energy display for the current test
      if (currentTestResults) {
        // Find the current test in the recalculated readings (last one)
        const currentTest = recalculatedData.readings[recalculatedData.readings.length - 1];
        if (currentTest) {
          testEnergy.textContent = `${currentTest.watt_hours_consumed.toFixed(4)} Wh`;
          carbonImpact.textContent = `${currentTest.carbon_grams_co2.toFixed(2)} gCO2`;

          // Update energy bar
          const energy = currentTest.watt_hours_consumed;
          let energyLevel = 'low';
          let barWidth = Math.min(energy * 10, 100); // Scale for visualization

          if (energy > 0.5) energyLevel = 'medium';
          if (energy > 1.0) energyLevel = 'high';

          testEnergyBar.style.width = `${barWidth}%`;
          testEnergyBar.className = `energy-bar energy-${energyLevel} h-4 rounded-full`;
        }
      }
    }

    // ===== INJECTION MANAGEMENT =====
    let injectionCounter = 0;
    const injections = [];

    function addInjection(description = '', content = '') {
      const id = `injection_${injectionCounter++}`;
      const injection = { id, description, content };
      injections.push(injection);

      const injectionHTML = `
        <div class="border rounded p-3 bg-gray-50" id="${id}">
          <div class="flex justify-between items-start mb-2">
            <input type="text" class="flex-1 p-1 border rounded text-sm injection-desc" 
                   placeholder="Injection Type (e.g., system_prompt, tool_results, memory, cot)" 
                   value="${description}">
            <button class="ml-2 text-red-600 hover:text-red-800 text-sm remove-injection" data-id="${id}">‚úï</button>
          </div>
          <textarea class="w-full p-2 border rounded text-sm injection-content" 
                    placeholder="Enter injection content...">${content}</textarea>
        </div>
      `;

      document.getElementById('injectionsContainer').insertAdjacentHTML('beforeend', injectionHTML);

      // Add event listeners
      document.querySelector(`#${id} .remove-injection`).addEventListener('click', function () {
        removeInjection(id);
      });
    }

    function removeInjection(id) {
      const index = injections.findIndex(inj => inj.id === id);
      if (index > -1) injections.splice(index, 1);
      document.getElementById(id).remove();
    }

    function getInjections() {
      const result = [];
      document.querySelectorAll('#injectionsContainer > div').forEach(div => {
        const desc = div.querySelector('.injection-desc').value;
        const content = div.querySelector('.injection-content').value;
        if (content.trim()) {
          result.push({ description: desc || 'Unnamed', content: content.trim() });
        }
      });
      return result;
    }

    // Add event listener for add button
    document.getElementById('addInjectionBtn').addEventListener('click', () => addInjection());

    // Note: no default injections; system prompt is controlled by the fixed field above.

    // ===== RUN TEST (UPDATED FOR NEW INJECTION SYSTEM & BATCH TRIGGER) =====
    async function runEnergyTest() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        alert('WebSocket not connected. Please refresh the page.');
        return;
      }

      if (!modelSelect.value || /No models/i.test(modelSelect.value)) {
        alert('No valid model selected. Start Ollama and pick a model.');
        return;
      }

      // Check for Batch Mode
      const liveChecked = document.getElementById('enableLivePower')?.checked === true;
      const batchRuns = parseInt(document.getElementById('raplBatchRuns').value) || 1;

      if (liveChecked && batchRuns > 1) {
        // Trigger Batch Handler instead
        await runRaplBatchHandler();
        return;
      }

      responseOutput.textContent = '';
      currentTestResults = null;
      inThinking = false;
      answerStarted = false;
      stopGenerationProgress(true);
      if (cliLog) cliLog.innerHTML = '';

      if (liveChecked) openCliModal();

      let payload;
      try {
        payload = buildEnergyPayload(false);
      } catch (e) {
        alert(e.message);
        return;
      }

      // Brief CLI log to confirm injections
      const sysPreview = (payload.system || '').slice(0, 200).replace(/\n/g, ' ');
      appendCliLog(`üîß System prompt set (${payload.system?.length || 0} chars): ${sysPreview}${(payload.system && payload.system.length > 200) ? '‚Ä¶' : ''}`);
      appendCliLog(`üß© Injections meta: ${JSON.stringify(payload.injection_params?.metadata || {})}`);
      if (payload.seed) appendCliLog(`üé≤ Seed: ${payload.seed}`);

      console.log('üì§ Sending payload:', payload);

      ws.send(JSON.stringify(payload));
      runTest.disabled = true;
      runTest.innerHTML = '<span class="animate-spin mr-2">‚Üª</span> Running...';
      stopTest.disabled = false;
      stopTest.classList.remove('bg-gray-100', 'text-gray-400', 'cursor-not-allowed');
      stopTest.classList.add('btn-danger', 'hover:bg-red-700');
    }
    function stopEnergyTest() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        batchStopRequested = true;
        stopTest.disabled = true;
        stopTest.textContent = 'Stopping...';
        ws.send(JSON.stringify({ command: 'cancel' }));
      }
    }

    async function handleTestCompletion(data) {
      runTest.disabled = false;
      runTest.textContent = 'Run Energy Test';
      stopTest.disabled = true;
      stopTest.textContent = 'Stop Test';

      if (data.error) {
        alert(`Test failed: ${data.error}`);
        return;
      }

      // In batch mode, just stash the latest result and let the batch handler
      // decide when to update the main UI (only once at the end).
      if (batchRunning) {
        _raplLastBatchResult = data;
      } else {
        currentTestResults = data;

        // Update energy display
        updateEnergyDisplay(data.energy_metrics);

        // Update results display
        updateResultsDisplay(data);

        // Update chart
        updateEnergyChart(
          data.energy_metrics.watt_hours_consumed,
          data.energy_metrics.energy_efficiency_score
        );

        // Update session summary
        await updateSessionSummary();

        const usedBenchmark = data.energy_metrics.benchmark_used;
        if (usedBenchmark && benchmarkSwitcher && usedBenchmark !== benchmarkSwitcher.value) {
          // Refresh benchmarks to ensure we have the latest
          await loadBenchmarks();

          // Select the benchmark
          const opt = Array.from(benchmarkSwitcher.options).find(o => o.value === usedBenchmark);
          if (opt) {
            benchmarkSwitcher.value = usedBenchmark;
            updateBenchmarkInfo();
          }
        }

        // Analyze modification impact
        analyzeModificationImpact(data);

        // If this was a single RAPL-enabled run with a valid measurement, record it into the RAPL table
        if (!batchRunning && data.live_power_metrics && data.live_power_metrics.measured_wh_per_1000_tokens != null) {
          const now = new Date();
          const ts = now.toLocaleTimeString();
          const raplWhPer1k = data.live_power_metrics.measured_wh_per_1000_tokens;
          const inTok = data.basic_metrics?.prompt_tokens ?? null;
          const outTok = data.basic_metrics?.completion_tokens ?? null;
          raplBatchSummaries.push({
            id: `${Date.now()}_${Math.random().toString(36).slice(2)}`,
            time: ts,
            runs: 1,
            meanWhPer1k: raplWhPer1k,
            medianWhPer1k: raplWhPer1k,
            stdWhPer1k: 0,
            p5WhPer1k: raplWhPer1k,
            p95WhPer1k: raplWhPer1k,
            cv: 0,
            meanInputTokens: inTok,
            medianInputTokens: inTok,
            meanOutputTokens: outTok,
            medianOutputTokens: outTok,
          });
          renderRaplBatchTable();
        }
      }

      // Resolve any pending batch run
      if (batchRunning && typeof window._raplBatchResolve === 'function') {
        const resolve = window._raplBatchResolve;
        window._raplBatchResolve = null;
        resolve(data);
      }

      // Resolve any pending crossover run
      if (typeof window._raplCrossoverResolve === 'function') {
        const resolveX = window._raplCrossoverResolve;
        window._raplCrossoverResolve = null;
        resolveX(data);
      }
    }

    async function runRaplBatchHandler() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        alert('WebSocket not connected. Please refresh the page.');
        return;
      }

      const runsInput = document.getElementById('raplBatchRuns');
      const totalRuns = parseInt(runsInput.value, 10) || 1;

      // Prepare CLI terminal
      if (cliLog) cliLog.innerHTML = '';
      openCliModal();
      appendCliLog(`üìä Starting RAPL batch: ${totalRuns} run(s) with current query + injections`);

      batchRunning = true;
      batchStopRequested = false;
      let completed = 0;
      const raplValues = [];
      const raplTotalWhValues = [];
      const ttftArr = [];
      const decodeArr = [];
      const runDurArr = [];
      const thinkTokArr = [];
      const inputTokensArr = [];
      const outputTokensArr = [];
      _raplBatchFirstDuration = null;

      for (let i = 0; i < totalRuns; i++) {
        if (batchStopRequested) {
          appendCliLog(`‚èπ Batch stop requested after ${completed} run(s).`);
          break;
        }

        appendCliLog(`\n===== Batch Run ${i + 1}/${totalRuns} =====`);

        // Log current prompt and injections for this run
        const currentQuery = userPrompt.value.trim();
        appendCliLog(`üìù User query: ${currentQuery || '(empty)'}`);
        const injList = getInjections();
        if (injList.length > 0) {
          appendCliLog('üîß Injections:');
          injList.forEach((inj, idx) => {
            appendCliLog(`  [${idx + 1}] ${inj.description || 'Unnamed'}: ${inj.content.substring(0, 200)}${inj.content.length > 200 ? '‚Ä¶' : ''}`);
          });
        } else {
          appendCliLog('üîß Injections: (none)');
        }

        let payload;
        try {
          payload = buildEnergyPayload(true);
        } catch (e) {
          appendCliLog(`‚ùå Skipping run: ${e.message}`);
          break;
        }

        ws.send(JSON.stringify(payload));

        const data = await new Promise(resolve => {
          window._raplBatchResolve = resolve;
        });

        if (data && data.basic_metrics) {
          completed++;
          const totalTokens = data.basic_metrics.total_tokens;
          const promptTokens = data.basic_metrics.prompt_tokens ?? null;
          const completionTokens = data.basic_metrics.completion_tokens ?? null;
          const latency = data.basic_metrics.latency;
          const energyWh = data.energy_metrics.watt_hours_consumed;
          const raplWhPer1k = data.live_power_metrics && data.live_power_metrics.measured_wh_per_1000_tokens;
          const raplTotalWh = (data.live_power_metrics && data.live_power_metrics.total_wh != null) ? data.live_power_metrics.total_wh : null;
          const ttft = data.live_power_metrics && data.live_power_metrics.ttft_seconds;
          const decDur = data.live_power_metrics && data.live_power_metrics.decode_duration_seconds;
          const runDur = data.live_power_metrics && data.live_power_metrics.run_duration_seconds;
          const thinkTok = (data.token_metrics && data.token_metrics.breakdown && data.token_metrics.breakdown.generation && (data.token_metrics.breakdown.generation.thinking_tokens != null)) ? data.token_metrics.breakdown.generation.thinking_tokens : null;

          if (raplWhPer1k != null) raplValues.push(raplWhPer1k);
          if (raplTotalWh != null) raplTotalWhValues.push(raplTotalWh);
          if (promptTokens != null) inputTokensArr.push(promptTokens);
          if (completionTokens != null) outputTokensArr.push(completionTokens);
          if (typeof ttft === 'number') ttftArr.push(ttft);
          if (typeof decDur === 'number') decodeArr.push(decDur);
          if (typeof runDur === 'number') runDurArr.push(runDur);
          if (typeof thinkTok === 'number') thinkTokArr.push(thinkTok);

          // Record first-run duration for ETA
          if (_raplBatchFirstDuration === null && latency && latency > 0) {
            _raplBatchFirstDuration = latency;
          }

          appendCliLog(
            `Run ${completed}: input=${promptTokens ?? 'n/a'} tok, output=${completionTokens ?? 'n/a'} tok, total=${totalTokens}, ` +
            `latency=${latency.toFixed(2)}s, energy=${energyWh.toFixed(4)} Wh, ` +
            `TTFT=${(typeof ttft === 'number') ? ttft.toFixed(3) : 'n/a'}s, ` +
            `Decode=${(typeof decDur === 'number') ? decDur.toFixed(3) : 'n/a'}s, ` +
            `RAPL Total Wh=${raplTotalWh != null ? raplTotalWh.toFixed(6) : 'n/a'}, ` +
            `RAPL Wh/1K=${raplWhPer1k != null ? raplWhPer1k.toFixed(4) : 'n/a'}`
          );

          // Estimated remaining time based on first run
          if (_raplBatchFirstDuration !== null && completed < totalRuns) {
            const remainingRuns = totalRuns - completed;
            const etaSeconds = remainingRuns * _raplBatchFirstDuration;
            const minutes = Math.floor(etaSeconds / 60);
            const seconds = Math.round(etaSeconds % 60);
            appendCliLog(
              `  Approx. time remaining: ${minutes > 0 ? minutes + 'm ' : ''}${seconds}s for ${remainingRuns} run(s)`
            );
          }
        } else {
          appendCliLog('‚ö†Ô∏è Run returned no basic metrics; skipping from stats.');
        }
      }

      batchRunning = false;
      batchStopRequested = false;

      if (raplValues.length > 0) {
        const meanOf = arr => arr.reduce((s, x) => s + x, 0) / arr.length;
        const medianOf = arr => { const a = [...arr].sort((a, b) => a - b); const n = a.length; return n % 2 ? a[(n - 1) / 2] : 0.5 * (a[n / 2 - 1] + a[n / 2]); };
        const sorted = [...raplValues].sort((a, b) => a - b);
        const n = sorted.length;
        const mean = sorted.reduce((s, x) => s + x, 0) / n;
        const median = n % 2 === 1 ? sorted[(n - 1) / 2] : 0.5 * (sorted[n / 2 - 1] + sorted[n / 2]);
        const varVal = sorted.reduce((s, x) => s + (x - mean) * (x - mean), 0) / n;
        const std = Math.sqrt(varVal);
        const p5 = sorted[Math.max(Math.floor(n * 0.05) - 1, 0)];
        const p95 = sorted[Math.min(Math.floor(n * 0.95), n - 1)];
        const cv = std / mean;

        // Measured Total Wh stats (if available)
        let meanTotWh = null;
        let medianTotWh = null;
        if (raplTotalWhValues.length > 0) {
          const sortedWh = [...raplTotalWhValues].sort((a, b) => a - b);
          const nwh = sortedWh.length;
          meanTotWh = sortedWh.reduce((s, x) => s + x, 0) / nwh;
          medianTotWh = nwh % 2 === 1 ? sortedWh[(nwh - 1) / 2] : 0.5 * (sortedWh[nwh / 2 - 1] + sortedWh[nwh / 2]);
        }

        // Thinking tokens and timing stats
        const meanThink = thinkTokArr.length ? meanOf(thinkTokArr) : null;
        const medianThink = thinkTokArr.length ? medianOf(thinkTokArr) : null;
        const meanTTFT = ttftArr.length ? meanOf(ttftArr) : null;
        const medianTTFT = ttftArr.length ? medianOf(ttftArr) : null;
        const meanDecode = decodeArr.length ? meanOf(decodeArr) : null;
        const medianDecode = decodeArr.length ? medianOf(decodeArr) : null;
        const meanRunDur = runDurArr.length ? meanOf(runDurArr) : null;
        const medianRunDur = runDurArr.length ? medianOf(runDurArr) : null;

        // Compute token statistics
        const meanIn = inputTokensArr.length ? (inputTokensArr.reduce((s, x) => s + x, 0) / inputTokensArr.length) : null;
        const meanOut = outputTokensArr.length ? (outputTokensArr.reduce((s, x) => s + x, 0) / outputTokensArr.length) : null;
        const medIn = inputTokensArr.length ? (() => {
          const t = [...inputTokensArr].sort((a, b) => a - b); const n2 = t.length; return n2 % 2 ? t[(n2 - 1) / 2] : 0.5 * (t[n2 / 2 - 1] + t[n2 / 2]);
        })() : null;
        const medOut = outputTokensArr.length ? (() => {
          const t = [...outputTokensArr].sort((a, b) => a - b); const n2 = t.length; return n2 % 2 ? t[(n2 - 1) / 2] : 0.5 * (t[n2 / 2 - 1] + t[n2 / 2]);
        })() : null;

        // Calculate injected tokens from the last result (assuming constant for batch)
        let injectedTokensVal = 0;
        if (_raplLastBatchResult && _raplLastBatchResult.token_metrics && _raplLastBatchResult.token_metrics.breakdown) {
          injectedTokensVal = _raplLastBatchResult.token_metrics.breakdown.injected?.total_injection_tokens || 0;
        }

        appendCliLog('\nüìà RAPL Batch Summary (UI prompt + injections)');
        appendCliLog(`  Successful runs: ${n}`);
        appendCliLog(`  Mean:   ${mean.toFixed(4)} Wh/1K`);
        appendCliLog(`  Median: ${median.toFixed(4)} Wh/1K`);
        appendCliLog(`  Std:    ${std.toFixed(4)} Wh/1K`);
        appendCliLog(`  5‚Äì95%:  ${p5.toFixed(4)} ‚Äì ${p95.toFixed(4)} Wh/1K`);
        appendCliLog(`  CV:     ${cv.toFixed(4)}`);
        if (meanTotWh != null || medianTotWh != null) {
          appendCliLog(`  Mean Total Wh:   ${meanTotWh != null ? meanTotWh.toFixed(6) : 'n/a'} Wh`);
          appendCliLog(`  Median Total Wh: ${medianTotWh != null ? medianTotWh.toFixed(6) : 'n/a'} Wh`);
        }
        if (meanThink != null || medianThink != null) {
          appendCliLog(`  Thinking tokens Œº/med: ${meanThink != null ? meanThink.toFixed(0) : 'n/a'} / ${medianThink != null ? medianThink.toFixed(0) : 'n/a'}`);
        }
        if (meanTTFT != null || medianTTFT != null) {
          appendCliLog(`  TTFT Œº/med: ${meanTTFT != null ? meanTTFT.toFixed(3) : 'n/a'}s / ${medianTTFT != null ? medianTTFT.toFixed(3) : 'n/a'}s`);
        }
        if (meanDecode != null || medianDecode != null) {
          appendCliLog(`  Decode Œº/med: ${meanDecode != null ? meanDecode.toFixed(3) : 'n/a'}s / ${medianDecode != null ? medianDecode.toFixed(3) : 'n/a'}s`);
        }
        if (meanRunDur != null || medianRunDur != null) {
          appendCliLog(`  Run Œº/med: ${meanRunDur != null ? meanRunDur.toFixed(3) : 'n/a'}s / ${medianRunDur != null ? medianRunDur.toFixed(3) : 'n/a'}s`);
        }
        if (meanIn != null || meanOut != null) {
          appendCliLog(`  Input tokens Œº: ${meanIn != null ? meanIn.toFixed(0) : 'n/a'}`);
          appendCliLog(`  Output tokens Œº: ${meanOut != null ? meanOut.toFixed(0) : 'n/a'}`);
        }
        if (injectedTokensVal > 0) {
          appendCliLog(`  Injected tokens: ${injectedTokensVal}`);
        }

        // Store a simple summary row for the batch table
        const now = new Date();
        const ts = now.toLocaleTimeString();
        raplBatchSummaries.push({
          id: `${Date.now()}_${Math.random().toString(36).slice(2)}`,
          time: ts,
          runs: n,
          injectedTokens: injectedTokensVal,
          meanWhPer1k: mean,
          medianWhPer1k: median,
          stdWhPer1k: std,
          p5WhPer1k: p5,
          p95WhPer1k: p95,
          cv,
          meanInputTokens: meanIn,
          medianInputTokens: medIn,
          meanOutputTokens: meanOut,
          medianOutputTokens: medOut,
          meanTotalWh: meanTotWh,
          medianTotalWh: medianTotWh,
          meanThinkingTokens: meanThink,
          medianThinkingTokens: medianThink,
          meanTTFT: meanTTFT,
          medianTTFT: medianTTFT,
          meanDecode: meanDecode,
          medianDecode: medianDecode,
          meanRunDur: meanRunDur,
          medianRunDur: medianRunDur,
        });
        renderRaplBatchTable();
      } else {
        appendCliLog('\n‚ö†Ô∏è No valid RAPL Wh/1K values collected in batch.');
      }

      // After batch completes, if we have a last successful result, apply it
      // to the main single-run UI so you can inspect one concrete run.
      if (_raplLastBatchResult) {
        currentTestResults = _raplLastBatchResult;
        updateEnergyDisplay(_raplLastBatchResult.energy_metrics);
        updateResultsDisplay(_raplLastBatchResult);
        updateEnergyChart(_raplLastBatchResult.energy_metrics.watt_hours_consumed, _raplLastBatchResult.energy_metrics.energy_efficiency_score);
        await updateSessionSummary();
        analyzeModificationImpact(_raplLastBatchResult);
      }
    }

    async function runRaplCrossoverHandler() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        alert('WebSocket not connected. Please refresh the page.');
        return;
      }
      // Ensure CLI modal is visible for live progress
      openCliModal();

      const startTokens = parseInt(document.getElementById('crossoverStartTokens').value) || 100;
      const stepTokens = parseInt(document.getElementById('crossoverStepTokens').value) || 200;
      const maxSteps = parseInt(document.getElementById('crossoverMaxSteps').value) || 10;
      const tableBody = document.getElementById('raplCrossoverTableBody');
      if (tableBody) tableBody.innerHTML = '';

      appendCliLog('üö¶ Starting RAPL Crossover Finder...');
      let tokensTarget = startTokens;
      for (let i = 1; i <= maxSteps; i++) {
        // Build payload and inflate user prompt approximately to reach tokensTarget (heuristic: 1 token ‚âà 4 chars)
        let payload;
        try { payload = buildEnergyPayload(true); } catch (e) { alert(e.message); return; }
        const base = userPrompt.value.trim();
        // Create a padding string that tokenizes into many distinct tokens across models
        // Use space-separated alphanumeric tokens to avoid aggressive BPE merges
        const padWordCount = Math.max(0, tokensTarget);
        const pad = padWordCount > 0 ? Array.from({ length: padWordCount }, (_, k) => `w${k}`).join(' ') : '';
        payload.user_prompt = base + (pad ? ('\n' + pad) : '');
        payload.user = payload.user_prompt;

        ws.send(JSON.stringify(payload));
        const data = await new Promise(resolve => { window._raplCrossoverResolve = resolve; });

        const lpm = data && data.live_power_metrics ? data.live_power_metrics : {};
        const promptTok = data && data.basic_metrics ? (data.basic_metrics.prompt_tokens ?? null) : null;
        const preWh = (lpm.prefill_wh != null) ? lpm.prefill_wh : null;
        const decWh = (lpm.decode_wh != null) ? lpm.decode_wh : null;
        const totWh = (lpm.total_wh != null) ? lpm.total_wh : null;
        const wh1k = (lpm.measured_wh_per_1000_tokens != null) ? lpm.measured_wh_per_1000_tokens : null;

        // Append row
        if (tableBody) {
          const tr = document.createElement('tr');
          tr.className = 'hover:bg-gray-50';
          tr.innerHTML = `
            <td class="px-3 py-2 whitespace-nowrap text-gray-500">${i}</td>
            <td class="px-3 py-2 whitespace-nowrap text-gray-900">${promptTok ?? 'n/a'}</td>
            <td class="px-3 py-2 whitespace-nowrap">${preWh != null ? preWh.toFixed(6) : '-'}</td>
            <td class="px-3 py-2 whitespace-nowrap">${decWh != null ? decWh.toFixed(6) : '-'}</td>
            <td class="px-3 py-2 whitespace-nowrap">${totWh != null ? totWh.toFixed(6) : '-'}</td>
            <td class="px-3 py-2 whitespace-nowrap">${wh1k != null ? wh1k.toFixed(4) : '-'}</td>
            <td class="px-3 py-2 whitespace-nowrap">${(preWh != null && decWh != null && preWh > decWh) ? '‚úÖ' : ''}</td>
          `;
          tableBody.appendChild(tr);
        }

        if (preWh != null && decWh != null && preWh > decWh) {
          appendCliLog(`üõë Crossover reached at run ${i} (Prefill > Decode).`);
          break;
        }
        tokensTarget += stepTokens;
      }
      appendCliLog('‚úÖ Crossover Finder finished.');
    }
    function updateEnergyDisplay(energyMetrics) {
      const energy = energyMetrics.watt_hours_consumed;
      const carbon = energyMetrics.carbon_grams_co2;

      // Single precise line for consistency
      testEnergy.textContent = `${energy.toFixed(4)} Wh`;
      carbonImpact.textContent = `${carbon.toFixed(2)} gCO2`;
      // Per-run RAPL metrics (if available on this response)
      if (currentTestResults && currentTestResults.live_power_metrics) {
        const lpm = currentTestResults.live_power_metrics;
        if (lpm.measured_wh_per_1000_tokens != null) {
          raplEfficiency.textContent = `${lpm.measured_wh_per_1000_tokens.toFixed(4)} Wh/1K`;
        }
        // Prefill/Decode display if available
        const prefillEl = document.getElementById('prefillEnergy');
        const decodeEl = document.getElementById('decodeEnergy');
        if (prefillEl) {
          const prefillVal = (lpm.calib_prefill_est_wh != null) ? lpm.calib_prefill_est_wh : ((lpm.prefill_wh_active != null) ? lpm.prefill_wh_active : lpm.prefill_wh);
          if (prefillVal != null) {
            const per1kIn = (lpm.calib_prefill_per_1000_input_tokens != null) ? lpm.calib_prefill_per_1000_input_tokens : ((lpm.prefill_active_per_1000_input_tokens != null) ? lpm.prefill_active_per_1000_input_tokens : lpm.prefill_wh_per_1000_input_tokens);
            prefillEl.textContent = `${prefillVal.toFixed(6)} Wh${per1kIn != null ? ` (${per1kIn.toFixed(4)} Wh/1K input)` : ''}`;
          } else {
            prefillEl.textContent = '-';
          }
        }
        if (decodeEl) {
          const decodeVal = (lpm.calib_expected_decode_wh != null) ? lpm.calib_expected_decode_wh : ((lpm.decode_wh_active != null) ? lpm.decode_wh_active : lpm.decode_wh);
          if (decodeVal != null) {
            const per1kOut = (lpm.calib_baseline_per_1000_output_tokens != null) ? lpm.calib_baseline_per_1000_output_tokens : ((lpm.decode_active_per_1000_output_tokens != null) ? lpm.decode_active_per_1000_output_tokens : lpm.decode_wh_per_1000_output_tokens);
            decodeEl.textContent = `${decodeVal.toFixed(6)} Wh${per1kOut != null ? ` (${per1kOut.toFixed(4)} Wh/1K output)` : ''}`;
          } else {
            decodeEl.textContent = '-';
          }
        }

        // Update Prefill vs Decode chart (only when both values available)
        const prefillChartVal = (lpm.calib_prefill_est_wh != null) ? lpm.calib_prefill_est_wh : ((lpm.prefill_wh_active != null) ? lpm.prefill_wh_active : lpm.prefill_wh);
        const decodeChartVal = (lpm.calib_expected_decode_wh != null) ? lpm.calib_expected_decode_wh : ((lpm.decode_wh_active != null) ? lpm.decode_wh_active : lpm.decode_wh);
        if (prefillDecodeChart && prefillChartVal != null && decodeChartVal != null) {
          const labels = prefillDecodeChart.data.labels;
          labels.push(`Test ${labels.length + 1}`);
          if (labels.length > 20) labels.shift();
          const ds0 = prefillDecodeChart.data.datasets[0].data;
          const ds1 = prefillDecodeChart.data.datasets[1].data;
          ds0.push(prefillChartVal);
          ds1.push(decodeChartVal);
          if (ds0.length > 20) ds0.shift();
          if (ds1.length > 20) ds1.shift();
          prefillDecodeChart.update();
        }
      } else {
        raplEfficiency.textContent = '0.00';
        const prefillEl = document.getElementById('prefillEnergy');
        const decodeEl = document.getElementById('decodeEnergy');
        if (prefillEl) prefillEl.textContent = '-';
        if (decodeEl) decodeEl.textContent = '-';
      }

      // Update energy bar
      let energyLevel = 'low';
      let barWidth = Math.min(energy * 10, 100); // Scale for visualization

      if (energy > 0.5) energyLevel = 'medium';
      if (energy > 1.0) energyLevel = 'high';

      testEnergyBar.style.width = `${barWidth}%`;
      testEnergyBar.className = `energy-bar energy-${energyLevel} h-4 rounded-full`;
    }

    let tokenChart = null;

    function updateResultsDisplay(data) {
      resultStrategy.textContent = data.strategy;
      resultTokens.textContent = data.basic_metrics.total_tokens;
      resultLatency.textContent = `${data.basic_metrics.latency.toFixed(2)}s`;
      resultTokensPerSec.textContent = data.basic_metrics.tokens_per_second.toFixed(1);

      // Update token breakdown display
      if (data.token_metrics && data.token_metrics.breakdown) {
        const breakdown = data.token_metrics.breakdown;
        const original = breakdown.original || {};
        const generation = breakdown.generation || {};
        const injected = breakdown.injected || {};

        const userTokens = original.total_original_tokens ?? 0;
        const thinkingTokens = generation.thinking_tokens ?? 0;
        const contentTokens = (generation.content_tokens != null) ? generation.content_tokens : (generation.direct_output_tokens ?? 0);
        const outputTokens = contentTokens;
        const injectionOverhead = injected.total_injection_tokens ?? 0;

        // Update summary text
        document.getElementById('inputTokensVal').textContent = userTokens;
        document.getElementById('overheadTokensVal').textContent = injectionOverhead;
        const thinkEl = document.getElementById('thinkingTokensVal');
        if (thinkEl) thinkEl.textContent = thinkingTokens;
        document.getElementById('outputTokensVal').textContent = outputTokens;

        if (Array.isArray(breakdown.analysis_notes) && breakdown.analysis_notes.length > 0) {
          tokenAnalysisNotes.textContent = breakdown.analysis_notes.join('. ') + '.';
        }

        // RAPL energy metrics into Token Analysis summary if present
        const lpm = data.live_power_metrics || {};
        const prefillPer = document.getElementById('prefillPer1kIn');
        const decodePer = document.getElementById('decodePer1kOut');
        const ewPer = document.getElementById('ewOutPer1k');
        if (prefillPer) prefillPer.textContent = (lpm.calib_prefill_per_1000_input_tokens != null ? lpm.calib_prefill_per_1000_input_tokens : (lpm.prefill_active_per_1000_input_tokens != null ? lpm.prefill_active_per_1000_input_tokens : lpm.prefill_wh_per_1000_input_tokens)) != null ? (lpm.calib_prefill_per_1000_input_tokens != null ? lpm.calib_prefill_per_1000_input_tokens : (lpm.prefill_active_per_1000_input_tokens != null ? lpm.prefill_active_per_1000_input_tokens : lpm.prefill_wh_per_1000_input_tokens)).toFixed(4) : '-';
        if (decodePer) decodePer.textContent = (lpm.calib_baseline_per_1000_output_tokens != null ? lpm.calib_baseline_per_1000_output_tokens : (lpm.decode_active_per_1000_output_tokens != null ? lpm.decode_active_per_1000_output_tokens : lpm.decode_wh_per_1000_output_tokens)) != null ? (lpm.calib_baseline_per_1000_output_tokens != null ? lpm.calib_baseline_per_1000_output_tokens : (lpm.decode_active_per_1000_output_tokens != null ? lpm.decode_active_per_1000_output_tokens : lpm.decode_wh_per_1000_output_tokens)).toFixed(4) : '-';
        if (ewPer) ewPer.textContent = (lpm.measured_wh_per_1000_tokens != null) ? lpm.measured_wh_per_1000_tokens.toFixed(4) : '-';

        // Update Chart
        const ctx = document.getElementById('tokenBreakdownChart').getContext('2d');

        if (tokenChart) {
          tokenChart.destroy();
        }

        tokenChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: ['Token Distribution'],
            datasets: [
              {
                label: 'User Input',
                data: [userTokens],
                backgroundColor: '#10b981', // Green
                barThickness: 40
              },
              {
                label: 'Injection Overhead',
                data: [injectionOverhead],
                backgroundColor: '#f59e0b', // Yellow
                barThickness: 40
              },
              {
                label: 'Thinking Output',
                data: [thinkingTokens],
                backgroundColor: '#a855f7', // Purple
                barThickness: 40
              },
              {
                label: 'Model Output',
                data: [outputTokens],
                backgroundColor: '#3b82f6', // Blue
                barThickness: 40
              }
            ]
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { stacked: true, title: { display: true, text: 'Tokens' } },
              y: { stacked: true, display: false }
            },
            plugins: {
              legend: { position: 'top' },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    if (context.parsed.x !== null) {
                      label += context.parsed.x + ' tokens';
                    }
                    return label;
                  }
                }
              }
            }
          }
        });
      }

      efficiencyScore.textContent = data.energy_metrics.energy_efficiency_score.toFixed(4);
    }

    function updateEnergyChart(energyConsumption, intensity) {
      energyHistory.push({ energy: energyConsumption, intensity: intensity || 0 });
      if (energyHistory.length > 20) energyHistory.shift();

      energyChart.data.labels = energyHistory.map((_, i) => `Test ${i + 1}`);
      energyChart.data.datasets[0].data = energyHistory.map(h => h.energy);
      energyChart.data.datasets[1].data = energyHistory.map(h => h.intensity);
      energyChart.update();
    }

    function analyzeModificationImpact(data) {
      const modInfo = data.modification_info;
      const energyMetrics = data.energy_metrics;

      let impactText = '';

      if (modInfo.injection_overhead > 0) {
        const totalTokens = data.basic_metrics ? data.basic_metrics.total_tokens : null;
        const measuredWh = data.live_power_metrics && data.live_power_metrics.measured_wh ? data.live_power_metrics.measured_wh : null;
        const baseWh = measuredWh !== null ? measuredWh : energyMetrics.watt_hours_consumed;
        let energyOverhead = null;
        if (totalTokens && totalTokens > 0) {
          energyOverhead = baseWh * (modInfo.injection_overhead / totalTokens);
        }
        if (energyOverhead !== null) {
          impactText += `Prompt injection added ${modInfo.injection_overhead} tokens, which we estimate account for ~${energyOverhead.toFixed(6)} Wh of this run's energy. `;
        } else {
          impactText += `Prompt injection added ${modInfo.injection_overhead} tokens (energy impact estimate unavailable). `;
        }
      }

      if (modInfo.tool_integration_applied && modInfo.tool_integration_applied.total_tokens_added > 0) {
        impactText += `Tool integration added ${modInfo.tool_integration_applied.total_tokens_added} tokens from tool outputs. `;
      }

      if (!impactText) {
        impactText = 'No significant modifications detected.';
      }

      if (modificationImpact) {
        modificationImpact.textContent = impactText;
      }
    }

    async function updateSessionSummary() {
      try {
        const r = await fetch('/api/session-summary');
        const summary = await r.json();

        if (summary.error) return;

        sessionEnergy.textContent = `${summary.total_energy_wh.toFixed(4)} Wh`;
        sessionCarbon.textContent = `${summary.total_carbon_gco2.toFixed(2)} gCO2`;
        sessionEfficiency.textContent = `${summary.average_energy_per_1000_tokens.toFixed(4)} Wh/1K`;
        sessionTokens.textContent = summary.total_tokens;
        if (summary.rapl_session && typeof summary.rapl_session.measured_wh === 'number') {
          sessionRaplEnergy.textContent = `${summary.rapl_session.measured_wh.toFixed(6)} Wh`;
        }
      } catch (e) {
        console.error('Failed to update session summary:', e);
      }
    }

    function clearAllResults() {
      responseOutput.textContent = 'Run a test to see the model response here.';
      testEnergy.textContent = '0.00 Wh';
      testEnergyBar.style.width = '0%';
      efficiencyScore.textContent = '0.00';
      carbonImpact.textContent = '0.00';
      inThinking = false;
      answerStarted = false;

      resultStrategy.textContent = '-';
      resultTokens.textContent = '-';
      resultLatency.textContent = '-';
      resultTokensPerSec.textContent = '-';

      // Clear token breakdown
      if (inputTokens) inputTokens.textContent = '-';
      if (outputTokens) outputTokens.textContent = '-';
      if (injectionTokens) injectionTokens.textContent = '-';
      if (toolTokens) toolTokens.textContent = '-';
      tokenAnalysisNotes.textContent = 'Run a test to see detailed token breakdown.';
      const thinkEl = document.getElementById('thinkingTokensVal');
      if (thinkEl) thinkEl.textContent = '-';

      if (modificationImpact) {
        modificationImpact.textContent = 'Run a test to see energy impact analysis.';
      }

      // Clear chart
      energyHistory = [];
      energyChart.data.labels = [];
      energyChart.data.datasets[0].data = [];
      energyChart.update();
    }

    async function exportSessionData() {
      try {
        const r = await fetch('/api/export-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filepath: 'energy_test_session.json' })
        });

        if (r.ok) {
          alert('Session data exported to energy_test_session.json');
        } else {
          alert('Export failed');
        }
      } catch (e) {
        alert('Export error: ' + e.message);
      }
    }

    function openCliModal() {
      if (cliModal) cliModal.classList.remove('hidden');
    }

    function closeCliModal() {
      if (cliModal) cliModal.classList.add('hidden');
    }

    function appendCliLog(line) {
      if (!cliLog) return;
      const div = document.createElement('div');
      div.textContent = line;
      cliLog.appendChild(div);
      cliLog.scrollTop = cliLog.scrollHeight;
    }

    function startGenerationProgress() {
      _genStartMs = Date.now();
      _genSpinIdx = 0;
      _genProgressEl = document.createElement('div');
      _genProgressEl.textContent = 'output generation in progress 00:00';
      if (cliLog) {
        cliLog.appendChild(_genProgressEl);
        cliLog.scrollTop = cliLog.scrollHeight;
      }
      const spins = ['|', '/', '-', '\\'];
      _genTimer = setInterval(() => {
        const elapsed = Date.now() - _genStartMs;
        const s = Math.floor(elapsed / 1000);
        const m = Math.floor(s / 60);
        const rr = String(s % 60).padStart(2, '0');
        const sp = spins[_genSpinIdx % spins.length];
        _genSpinIdx++;
        if (_genProgressEl) {
          _genProgressEl.textContent = `output generation in progress ${sp} ${m}:${rr}`;
        }
      }, 200);
    }

    function stopGenerationProgress(silent = false) {
      if (_genTimer) {
        clearInterval(_genTimer);
        _genTimer = null;
      }
      if (_genProgressEl && !silent) {
        const elapsed = Date.now() - _genStartMs;
        const s = Math.floor(elapsed / 1000);
        const m = Math.floor(s / 60);
        const rr = String(s % 60).padStart(2, '0');
        _genProgressEl.textContent = `output generation complete in ${m}:${rr}`;
      }
      _genProgressEl = null;
    }

    async function init() {
      // Load all data
      await loadModels();
      await loadBenchmarks();
      await loadBenchmarks();
      await loadSystemPrompts();

      await updateSessionSummary();

      // Setup UI
      setupWebSocket();
      setupEventListeners();
      initChart();
      initPrefillDecodeChart();
      renderRaplBatchTable();

      // Check connection
      if (ws && ws.readyState === WebSocket.OPEN && connectionStatus) {
        connectionStatus.textContent = 'Connected';
        connectionStatus.className = 'px-4 py-2 rounded-full bg-green-100 text-green-700';
      }
    }

    // Call init to start everything
    init();
  </script>
</body>

</html>