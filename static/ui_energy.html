<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Energy Testing Lab - LLM Behavior Lab</title>
  <script src="/static/tailwind.min.js"></script>
  <script src="/static/chart.min.js"></script>
  <style>
    /* Modern UI Polish */
    body {
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      background-color: #f8fafc;
    }

    .card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .card:hover {
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    .model-output {
      white-space: pre-wrap;
      font-family: 'JetBrains Mono', 'Fira Code', ui-monospace, monospace;
      font-size: 0.9rem;
      line-height: 1.5;
    }

    .energy-bar {
      transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .energy-high {
      background: linear-gradient(90deg, #ef4444, #b91c1c);
    }

    .energy-medium {
      background: linear-gradient(90deg, #f59e0b, #d97706);
    }

    .energy-low {
      background: linear-gradient(90deg, #10b981, #059669);
    }

    .btn-primary {
      background: linear-gradient(135deg, #4f46e5 0%, #4338ca 100%);
      color: white;
      transition: all 0.2s;
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
    }

    .btn-danger {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
    }

    input[type="range"] {
      accent-color: #4f46e5;
    }
  </style>
</head>

<body class="bg-gray-50 p-4">
  <div class="max-w-7xl mx-auto space-y-6">

    <!-- Header -->
    <div class="bg-white rounded-lg shadow p-6">
      <div class="container mx-auto px-4 py-8 max-w-7xl">
        <!-- Header & Methodology -->
        <div class="flex justify-between items-center mb-8">
          <div>
            <h1 class="text-3xl font-bold text-gray-900">LLM Energy Testing Lab</h1>
            <p class="text-gray-600 mt-1">Measure real-world energy consumption and carbon footprint of LLM
              interactions.</p>
          </div>
          <button onclick="document.getElementById('methodologyModal').classList.remove('hidden')"
            class="text-indigo-600 hover:text-indigo-800 font-medium flex items-center">
            <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            Methodology & Metrics
          </button>
        </div>

        <!-- Methodology Modal -->
        <div id="methodologyModal"
          class="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full hidden z-50">
          <div class="relative top-20 mx-auto p-5 border w-full max-w-2xl shadow-lg rounded-md bg-white">
            <div class="flex justify-between items-center mb-4">
              <h3 class="text-xl font-bold text-gray-900">Methodology & Metrics</h3>
              <button onclick="document.getElementById('methodologyModal').classList.add('hidden')"
                class="text-gray-500 hover:text-gray-700">‚úï</button>
            </div>
            <div class="prose prose-sm max-w-none text-gray-600">
              <h4 class="font-bold text-gray-900">Energy Measurement</h4>
              <p>We use two methods to track energy:</p>
              <ul class="list-disc pl-5 mb-2">
                <li><strong>Live (RAPL):</strong> Direct hardware measurement using Intel/AMD RAPL interface. Measures
                  CPU/DRAM energy during inference. Accurate but requires local execution.</li>
                <li><strong>Estimated:</strong> Uses benchmark coefficients (Wh/1000 tokens) derived from hardware
                  specs. Good for approximation when live monitoring isn't available.</li>
              </ul>

              <h4 class="font-bold text-gray-900 mt-4">Metrics Explained</h4>
              <ul class="list-disc pl-5 mb-2">
                <li><strong>Wh/1000 Output Tokens:</strong> Energy intensity metric. Amortizes the total energy (Input +
                  Output) over the generated output tokens. Useful for comparing "cost of production".</li>
                <li><strong>Input/Output Split:</strong> Separate energy costs for processing prompt (prefill) and
                  generating tokens (decode). Used for more accurate estimation.</li>
                <li><strong>Injection Overhead:</strong> Extra tokens added by system prompts, tools, or context that
                  the user doesn't see but pays for in energy.</li>
              </ul>
            </div>
            <div class="mt-6 text-right">
              <button onclick="document.getElementById('methodologyModal').classList.add('hidden')"
                class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">Close</button>
            </div>
          </div>
        </div>
        <div class="flex items-center justify-between">
          <div>
            <h1 class="text-3xl font-bold text-gray-900">Energy Testing Lab</h1>
            </p>
          </div>
        </div>
      </div>

      <!-- Test Configuration -->
      <div class="bg-white rounded-lg shadow p-6 space-y-6">

        <!-- Model and Benchmark Selection -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Model Selection</label>
            <select id="modelSelect" class="w-full p-2 border rounded">
              <option>Loading models‚Ä¶</option>
            </select>
          </div>
        </div>

        <!-- Prompt Configuration -->
        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">User Query</label>
            <textarea id="userPrompt" class="w-full p-2 border rounded h-24"
              placeholder="Explain quantum computing in simple terms."></textarea>
            <div class="text-xs text-gray-500 mt-1">This is your actual query - the only \"original\" tokens</div>
          </div>
        </div>
      </div>

      <!-- Middleware Injections (separate card) -->
      <div class="card p-6 mb-6">
        <h3 class="text-lg font-semibold text-gray-900 mb-2">Middleware Injections</h3>
        <div class="text-sm text-gray-600 mb-3">
          Add any prompt injections below. Each one adds middleware overhead to your query. Common examples:
          ‚Ä¢ System prompts (5,000-7,000 tokens in commercial LLMs)
          ‚Ä¢ Tool results (web searches, database queries)
          ‚Ä¢ Memory/personalization context
          ‚Ä¢ Chain-of-thought instructions
        </div>

        <!-- Fixed System Prompt and Conversation Context as middleware -->
        <div class="space-y-3">
          <!-- System Prompt (fixed field with presets) -->
          <div>
            <h4 class="font-medium text-gray-900 mb-2">System Prompt (optional)</h4>
            <div class="flex flex-col md:flex-row md:items-center md:space-x-2 space-y-2 md:space-y-0 mb-2">
              <select id="systemPromptSelect" class="w-full md:w-1/3 p-2 border rounded">
                <option value="">Custom / empty</option>
              </select>
              <button id="clearSystemPromptBtn"
                class="px-3 py-1 bg-gray-200 text-gray-800 rounded text-xs hover:bg-gray-300">
                Clear System Prompt
              </button>
            </div>
            <p class="text-xs text-gray-500 mb-2">source: https://github.com/elder-plinius/CL4R1T4S</p>
            <textarea id="systemPromptText" class="w-full p-2 border rounded h-24"
              placeholder="Optional system prompt or middleware instructions (empty by default)"></textarea>
          </div>

          <!-- Conversation Context -->
          <div>
            <h4 class="font-medium text-gray-900 mb-2">Conversation Context</h4>
            <p class="text-xs text-gray-600 mb-2">
              Use this to accumulate relevant turns from the conversation that should be included as context.
              The latest user query and response can be injected below.
            </p>
            <div class="flex items-center mb-2">
              <button id="injectConversationBtn"
                class="px-3 py-1 bg-blue-600 text-white rounded text-xs hover:bg-blue-700">
                Inject conversation
              </button>
            </div>
            <textarea id="conversationContextText" class="w-full p-2 border rounded h-24"
              placeholder="Conversation context will be wrapped in &lt;conversation_context&gt; tags when sent."></textarea>
          </div>
        </div>

        <!-- Container for injections -->
        <div id="injectionsContainer" class="space-y-3">
          <!-- Injections will be added here -->
        </div>

        <!-- Add injection button -->
        <button id="addInjectionBtn" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 text-sm">
          + Add Prompt Injection
        </button>
      </div>

      <!-- Test Controls moved to separate card below -->
    </div>

    <!-- Results Display: Live vs Estimated hardware tests -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-6">

      <!-- Live Hardware Tests (RAPL) -->
      <div class="card p-6">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-lg font-medium text-gray-900 flex items-center">
            <span class="mr-2">üîå</span> Live Hardware Tests (RAPL)
            <span class="ml-2 text-xs bg-green-100 text-green-800 px-2 py-0.5 rounded-full">Linux Only</span>
          </h3>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <!-- Batch Config -->
          <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
            <h4 class="text-sm font-medium text-gray-700 mb-3">Batch Testing</h4>
            <div class="flex items-center gap-3">
              <div class="flex-1">
                <label class="block text-xs text-gray-500 mb-1">Number of Runs</label>
                <input type="number" id="raplBatchRuns" value="1" min="1" max="100"
                  class="w-full p-2 border rounded text-sm">
              </div>
              <div class="flex-1 pt-5">
                <p class="text-xs text-gray-500">Enable "Live Power" and click "Run Energy Test" to start batch.</p>
              </div>
            </div>
          </div>

          <!-- Calibration -->
          <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
            <h4 class="text-sm font-medium text-gray-700 mb-3">Calibration</h4>
            <div class="flex items-center gap-3">
              <div class="flex-1">
                <label class="block text-xs text-gray-500 mb-1">Calibration Runs</label>
                <input type="number" id="raplCalibrationRuns" value="5" min="3" max="20"
                  class="w-full p-2 border rounded text-sm">
              </div>
              <button id="runRaplCalibration"
                class="mt-4 bg-white border border-gray-300 text-gray-700 hover:bg-gray-50 px-3 py-1.5 rounded text-sm transition-colors">
                Calibrate
              </button>
            </div>
            <div id="raplCalibrationStatus" class="mt-2 text-xs text-gray-500"></div>
          </div>
        </div>

        
      </div> <!-- RAPL Batch Results moved to Test Results card -->

      <!-- Estimated Hardware Tests -->
      <div class="bg-white rounded-lg shadow p-6">
        <h3 class="text-xl font-semibold text-gray-900 mb-4">Estimated Hardware Tests</h3>
        <div class="space-y-4">
          <!-- Current Benchmark Info -->
          <div class="p-4 bg-blue-50 rounded">
            <div class="flex justify-between items-center">
              <div>
                <h4 class="font-medium text-blue-900">Current Benchmark</h4>
                <p class="text-sm text-blue-700" id="currentBenchmarkInfo">Loading...</p>
              </div>
              <button id="benchmarkInfoBtn" class="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700">
                ‚ÑπÔ∏è Info
              </button>
            </div>
          </div>

          <!-- Benchmark Switching -->
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">Switch Benchmark</label>
            <select id="benchmarkSwitcher" class="w-full p-2 border rounded">
              <option>Loading benchmarks...</option>
            </select>
            <button id="switchBenchmarkBtn"
              class="mt-2 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 disabled:opacity-50" disabled>
              Recalculate with Selected Benchmark
            </button>
          </div>

          <!-- Add Custom Benchmark -->
          <div class="border-t pt-4">
            <h4 class="font-medium text-gray-900 mb-2">Add Custom Benchmark</h4>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label class="block text-sm text-gray-600 mb-1">Name</label>
                <input type="text" id="customBenchmarkName" placeholder="e.g., RTX 3080"
                  class="w-full p-2 border rounded">
              </div>
              <div>
                <label class="block text-sm text-gray-600 mb-1">Wh/1000 tokens</label>
                <input type="number" id="customBenchmarkWattHours" step="0.01" placeholder="0.50"
                  class="w-full p-2 border rounded">
              </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-2">
              <div>
                <label class="block text-sm text-gray-600 mb-1">Description</label>
                <input type="text" id="customBenchmarkDesc" placeholder="NVIDIA RTX 3080 GPU"
                  class="w-full p-2 border rounded">
              </div>
              <div>
                <label class="block text-sm text-gray-600 mb-1">Hardware Specs</label>
                <input type="text" id="customBenchmarkSpecs" placeholder="12GB GDDR6X"
                  class="w-full p-2 border rounded">
              </div>
            </div>
            <button id="addCustomBenchmarkBtn"
              class="mt-2 px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700">
              Add Custom Benchmark
            </button>
          </div>

        </div>
      </div>
    </div>

    <!-- Response Output -->
    <div class="card p-6 mb-6">
      <h3 class="text-lg font-medium text-gray-900 mb-3">Response Output</h3>
      <!-- Response Output moved to main results area -->
    </div>

    <!-- Controls & Settings -->
    <div class="card p-6 mb-6">
      <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Temperature</label>
          <div class="flex items-center space-x-2">
            <input type="range" id="temperature" min="0" max="1" step="0.1" value="0.7"
              class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
            <span id="tempValue" class="text-sm text-gray-600 w-8">0.7</span>
          </div>
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Max Tokens</label>
          <input type="number" id="maxTokens" value="100"
            class="w-full p-2 border rounded-md focus:ring-indigo-500 focus:border-indigo-500">
        </div>
        <div>
          <label class="block text-sm font-medium text-gray-700 mb-1">Seed (Optional)</label>
          <input type="number" id="seedInput" placeholder="Random"
            class="w-full p-2 border rounded-md focus:ring-indigo-500 focus:border-indigo-500">
        </div>
      </div>

      <div class="flex flex-wrap items-center gap-4">
        <button id="runTest" class="btn-primary px-6 py-2.5 rounded-lg font-medium shadow-sm flex items-center">
          <span class="mr-2">‚ö°</span> Run Energy Test
        </button>
        <button id="stopTest" disabled
          class="bg-gray-100 text-gray-400 px-6 py-2.5 rounded-lg font-medium cursor-not-allowed">
          Stop
        </button>
        <div class="border-l pl-4 flex items-center gap-4">
          <label class="flex items-center space-x-2 cursor-pointer">
            <input type="checkbox" id="enableLivePower" class="w-4 h-4 text-indigo-600 rounded focus:ring-indigo-500">
            <span class="text-sm font-medium text-gray-700">Enable Live Power (RAPL)</span>
          </label>
          <button id="showLogs" class="text-gray-500 hover:text-gray-700 text-sm underline flex items-center">
            <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10">
              </path>
            </svg>
            Logs
          </button>
        </div>
        <div class="flex-grow"></div>
        <button id="clearResults"
          class="text-gray-600 hover:text-gray-900 px-4 py-2 text-sm font-medium flex items-center">
          <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16">
            </path>
          </svg>
          Clear
        </button>
        <button id="exportData"
          class="text-indigo-600 hover:text-indigo-800 px-4 py-2 text-sm font-medium flex items-center">
          <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path>
          </svg>
          Export
        </button>
      </div>
    </div>

    <!-- Test Results -->
    <div class="bg-white rounded-lg shadow p-6">
      <h3 class="text-xl font-semibold text-gray-900 mb-4">Test Results</h3>

      <!-- RAPL Batch Results full-width (moved here) -->
      <div class="mb-6">
        <h4 class="font-medium text-gray-900 mb-2">RAPL Batch Results (UI Prompt + Injections)</h4>
        <p class="text-xs text-gray-600 mb-2">
          Each row represents one completed batch of RAPL runs using the current UI configuration. These
          are not stored as benchmarks but as experimental results. You can remove rows individually.
        </p>
        <div class="overflow-x-auto">
          <table class="min-w-full text-xs text-left border">
            <thead class="bg-gray-100">
              <tr>
                <th class="px-2 py-1 border">Time</th>
                <th class="px-2 py-1 border">Runs</th>
                <th class="px-2 py-1 border">Mean Wh/1000 e-tokens</th>
                <th class="px-2 py-1 border">Median Wh/1000 e-tokens</th>
                <th class="px-2 py-1 border">Std Wh/1000 e-tokens</th>
                <th class="px-2 py-1 border">5‚Äì95% Wh/1000 e-tokens</th>
                <th class="px-2 py-1 border">CV</th>
                <th class="px-2 py-1 border">Query/Input Tokens (Œº/med)</th>
                <th class="px-2 py-1 border">Output Tokens (Œº/med)</th>
                <th class="px-2 py-1 border">Actions</th>
              </tr>
            </thead>
            <tbody id="raplBatchTableBody"></tbody>
          </table>
        </div>
      </div>

      <!-- Energy Consumption & Live Power -->
      <div class="mb-6 space-y-4">
        <h4 class="font-medium text-gray-900 mb-3">Energy Consumption</h4>

        <!-- Current Test Energy -->
        <div>
          <div class="flex justify-between text-sm mb-1">
            <span>Test Energy</span>
            <span id="testEnergy">0.00 Wh</span>
          </div>
          <div class="w-full bg-gray-200 rounded-full h-4">
            <div id="testEnergyBar" class="energy-bar energy-low h-4 rounded-full" style="width: 0%"></div>
          </div>
        </div>

        <!-- Efficiency Comparison -->
        <div class="grid grid-cols-2 gap-4">
          <div class="text-center p-3 bg-gray-50 rounded">
            <div class="text-2xl font-bold text-blue-600" id="efficiencyScore">0.00</div>
            <div class="text-sm text-gray-600">Wh/1000 e-tokens (net i/o energy-weighted output tokens)</div>
          </div>
          <div class="text-center p-3 bg-gray-50 rounded">
            <div class="text-2xl font-bold text-green-600" id="carbonImpact">0.00</div>
            <div class="text-sm text-gray-600">gCO2</div>
          </div>
          <div class="text-center p-3 bg-gray-50 rounded">
            <div class="text-2xl font-bold text-gray-600" id="raplEfficiency">0.00</div>
            <div class="text-sm text-gray-600">RAPL Measured Wh/1K</div>
          </div>
        </div>

        <!-- Live Power Metrics (Hidden by default) -->
        <div id="livePowerSection" class="mt-2 hidden">
          <h4 class="font-medium text-gray-900 mb-2">Live Power Measurements (RAPL)</h4>
          <div class="grid grid-cols-3 gap-2 text-center text-sm">
            <div class="bg-gray-50 p-2 rounded">
              <div class="text-gray-500">Baseline</div>
              <div class="font-bold" id="powerBaseline">-</div>
            </div>
            <div class="bg-gray-50 p-2 rounded">
              <div class="text-gray-500">Active</div>
              <div class="font-bold text-blue-600" id="powerActive">-</div>
            </div>
            <div class="bg-gray-50 p-2 rounded">
              <div class="text-gray-500">Measured Wh/1K</div>
              <div class="font-bold text-green-600" id="powerMeasured">-</div>
            </div>
          </div>
          <div class="mt-2 text-xs text-gray-500 text-center" id="powerAccuracy"></div>
        </div>

        <!-- Energy Chart -->
        <div class="mt-2">
          <canvas id="energyChart" width="400" height="200"></canvas>
        </div>
      </div>

      <!-- Token Breakdown Chart -->
      <div class="mb-6">
        <h4 class="font-medium text-gray-900 mb-3">Token Analysis</h4>
        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
          <canvas id="tokenBreakdownChart" width="400" height="120"></canvas>
        </div>
        <div class="mt-3 text-xs text-gray-600 flex justify-between">
          <span id="tokenAnalysisNotes">Run a test to see detailed token breakdown.</span>
          <div class="space-x-4">
            <span class="font-bold text-green-700">Input: <span id="inputTokensVal">-</span></span>
            <span class="font-bold text-yellow-700">Overhead: <span id="overheadTokensVal">-</span></span>
            <span class="font-bold text-blue-700">Output: <span id="outputTokensVal">-</span></span>
          </div>
        </div>
      </div>

      <div class="space-y-3">
        <div class="flex justify-between">
          <span class="text-gray-600">Strategy:</span>
          <span id="resultStrategy" class="font-medium">-</span>
        </div>
        <div class="flex justify-between">
          <span class="text-gray-600">Total Tokens:</span>
          <span id="resultTokens" class="font-medium">-</span>
        </div>
        <div class="flex justify-between">
          <span class="text-gray-600">Latency:</span>
          <span id="resultLatency" class="font-medium">-</span>
        </div>
        <div class="flex justify-between">
          <span class="text-gray-600">Tokens/Second:</span>
          <span id="resultTokensPerSec" class="font-medium">-</span>
        </div>
      </div>

      <!-- Modification Impact removed as requested -->
    </div>

  </div>

  <!-- Response Output -->
  <div class="bg-white rounded-lg shadow p-6">
    <h3 class="text-xl font-semibold text-gray-900 mb-4">Response Output</h3>
    <div id="responseOutput" class="model-output bg-gray-50 p-4 rounded min-h-32 border">
      Run a test to see the model response here.
    </div>
  </div>

  <!-- Session Energy Summary -->
  <div class="max-w-7xl mx-auto mt-6">
    <div class="bg-white rounded-lg shadow p-6">
      <h3 class="text-xl font-semibold text-gray-900 mb-4">Cummulative Session Summary</h3>
      <div class="grid grid-cols-1 md:grid-cols-5 gap-4">
        <div class="bg-blue-50 p-4 rounded-lg">
          <div class="text-sm text-blue-600 font-medium">Total Energy</div>
          <div id="sessionEnergy" class="text-2xl font-bold text-blue-900">0.00 Wh</div>
        </div>
        <div class="bg-green-50 p-4 rounded-lg">
          <div class="text-sm text-green-600 font-medium">Carbon Footprint</div>
          <div id="sessionCarbon" class="text-2xl font-bold text-green-900">0.00 gCO2</div>
        </div>
        <div class="bg-purple-50 p-4 rounded-lg">
          <div class="text-sm text-purple-600 font-medium">Energy Weight</div>
          <div id="sessionEfficiency" class="text-2xl font-bold text-purple-900">0.00 Wh/1000 e-tokens</div>
        </div>
        <div class="bg-orange-50 p-4 rounded-lg">
          <div class="text-sm text-orange-600 font-medium">Total Tokens</div>
          <div id="sessionTokens" class="text-2xl font-bold text-orange-900">0</div>
        </div>
        <div class="bg-gray-50 p-4 rounded-lg">
          <div class="text-sm text-gray-600 font-medium">RAPL Measured Energy</div>
          <div id="sessionRaplEnergy" class="text-2xl font-bold text-gray-900">0.000000 Wh</div>
        </div>
      </div>
    </div>
  </div>

  <div id="cliModal" class="fixed inset-0 hidden z-50">
    <div class="w-full h-full flex items-center justify-center bg-black bg-opacity-50">
      <div class="bg-white rounded-lg shadow-xl w-11/12 max-w-2xl p-4">
        <div class="flex items-center justify-between mb-2">
          <h3 class="text-lg font-semibold">Live Measurement Logs</h3>
          <button id="closeCliModalBtn" class="px-2 py-1 rounded bg-gray-200 hover:bg-gray-300">Close</button>
        </div>
        <div id="cliLog" class="bg-gray-900 text-green-200 p-3 rounded h-80 overflow-auto text-sm font-mono"></div>
      </div>
    </div>
  </div>

  <script>
    // DOM references
    const modelSelect = document.getElementById('modelSelect');
    const energyBenchmark = document.getElementById('energyBenchmark');
    const systemPromptSelect = document.getElementById('systemPromptSelect');
    const systemPromptText = document.getElementById('systemPromptText');
    const conversationContextText = document.getElementById('conversationContextText');
    const userPrompt = document.getElementById('userPrompt');
    const temperature = document.getElementById('temperature');
    const maxTokens = document.getElementById('maxTokens');
    const tempValue = document.getElementById('tempValue');
    const runTest = document.getElementById('runTest');
    const stopTest = document.getElementById('stopTest');
    const clearResults = document.getElementById('clearResults');
    const exportData = document.getElementById('exportData');
    const showLogs = document.getElementById('showLogs');
    const cliModal = document.getElementById('cliModal');
    const cliLog = document.getElementById('cliLog');
    const closeCliModalBtn = document.getElementById('closeCliModalBtn');

    // Benchmark controls
    const currentBenchmarkInfo = document.getElementById('currentBenchmarkInfo');
    const benchmarkInfoBtn = document.getElementById('benchmarkInfoBtn');
    const benchmarkSwitcher = document.getElementById('benchmarkSwitcher');
    const switchBenchmarkBtn = document.getElementById('switchBenchmarkBtn');
    const customBenchmarkName = document.getElementById('customBenchmarkName');
    const customBenchmarkWattHours = document.getElementById('customBenchmarkWattHours');
    const customBenchmarkDesc = document.getElementById('customBenchmarkDesc');
    const customBenchmarkSpecs = document.getElementById('customBenchmarkSpecs');
    const addCustomBenchmarkBtn = document.getElementById('addCustomBenchmarkBtn');
    const runRaplCalibration = document.getElementById('runRaplCalibration');
    const runRaplBatch = document.getElementById('runRaplBatch');
    const raplBatchTableBody = document.getElementById('raplBatchTableBody');

    // Token analysis elements
    const inputTokens = document.getElementById('inputTokens');
    const outputTokens = document.getElementById('outputTokens');
    const injectionTokens = document.getElementById('injectionTokens');
    const toolTokens = document.getElementById('toolTokens');
    const tokenAnalysisNotes = document.getElementById('tokenAnalysisNotes');

    // Results elements
    const sessionEnergy = document.getElementById('sessionEnergy');
    const sessionCarbon = document.getElementById('sessionCarbon');
    const sessionEfficiency = document.getElementById('sessionEfficiency');
    const sessionTokens = document.getElementById('sessionTokens');
    const sessionRaplEnergy = document.getElementById('sessionRaplEnergy');

    const testEnergy = document.getElementById('testEnergy');
    const testEnergyBar = document.getElementById('testEnergyBar');
    const efficiencyScore = document.getElementById('efficiencyScore');
    const carbonImpact = document.getElementById('carbonImpact');
    const raplEnergy = document.getElementById('raplEnergy');
    const raplEfficiency = document.getElementById('raplEfficiency');

    const resultStrategy = document.getElementById('resultStrategy');
    const resultTokens = document.getElementById('resultTokens');
    const resultLatency = document.getElementById('resultLatency');
    const resultTokensPerSec = document.getElementById('resultTokensPerSec');

    const modificationImpact = document.getElementById('modificationImpact');
    const responseOutput = document.getElementById('responseOutput');
    const connectionStatus = document.getElementById('connectionStatus');

    // State
    let ws = null;
    let energyHistory = [];
    let currentTestResults = null;
    let batchRunning = false;
    let batchStopRequested = false;
    let _raplBatchFirstDuration = null;
    let _raplLastBatchResult = null;
    let raplBatchSummaries = [];
    let systemPrompts = [];

    function renderRaplBatchTable() {
      if (!raplBatchTableBody) return;
      raplBatchTableBody.innerHTML = '';

      const sorted = raplBatchSummaries.slice().reverse();
      sorted.forEach(s => {
        const tr = document.createElement('tr');
        tr.className = 'hover:bg-gray-50';
        tr.innerHTML = `
            <td class="px-3 py-2 whitespace-nowrap text-gray-500">${s.time}</td>
            <td class="px-3 py-2 whitespace-nowrap font-medium text-gray-900">${s.runs}</td>
            <td class="px-3 py-2 whitespace-nowrap text-indigo-700 font-bold">${(s.meanWhPer1k ?? 0).toFixed(3)}</td>
            <td class="px-3 py-2 whitespace-nowrap text-indigo-600">${(s.medianWhPer1k ?? 0).toFixed(3)}</td>
            <td class="px-3 py-2 whitespace-nowrap text-gray-500">${(s.stdWhPer1k ?? 0).toFixed(3)}</td>
            <td class="px-3 py-2 whitespace-nowrap text-gray-500">${(s.p5WhPer1k != null && s.p95WhPer1k != null) ? `${s.p5WhPer1k.toFixed(3)} ‚Äì ${s.p95WhPer1k.toFixed(3)}` : 'n/a'}</td>
            <td class="px-3 py-2 whitespace-nowrap text-gray-500">${(s.cv ?? 0).toFixed(3)}</td>
            <td class="px-3 py-2 whitespace-nowrap text-green-700">${(s.meanInputTokens != null ? s.meanInputTokens.toFixed(0) : 'n/a')} / ${(s.medianInputTokens != null ? s.medianInputTokens.toFixed(0) : 'n/a')}</td>
            <td class="px-3 py-2 whitespace-nowrap text-blue-700">${(s.meanOutputTokens != null ? s.meanOutputTokens.toFixed(0) : 'n/a')} / ${(s.medianOutputTokens != null ? s.medianOutputTokens.toFixed(0) : 'n/a')}</td>
            <td class="px-3 py-2 whitespace-nowrap">
              <button data-id="${s.id}" class="text-red-600 hover:text-red-800 text-xs">Remove</button>
            </td>
          `;
        raplBatchTableBody.appendChild(tr);
      });

      raplBatchTableBody.querySelectorAll('button[data-id]').forEach(btn => {
        btn.addEventListener('click', () => {
          const id = btn.getAttribute('data-id');
          raplBatchSummaries = raplBatchSummaries.filter(r => String(r.id) !== String(id));
          renderRaplBatchTable();
        });
      });
    }

    // Chart
    let energyChart = null;

    // Initialize (called at bottom)

    async function loadModels() {
      console.log('üîÑ Attempting to load models...');
      try {
        const r = await fetch('/api/models');
        console.log('üì° Models API response status:', r.status);
        if (!r.ok) {
          const errorText = await r.text();
          console.error('‚ùå Models API request failed:', r.status, errorText);
          modelSelect.innerHTML = '<option>Error loading models (API failed)</option>';
          return;
        }
        const d = await r.json();
        console.log('‚úì Models API response data:', d);
        modelSelect.innerHTML = '';
        if (d.models && d.models.length > 0) {
          d.models.forEach(model => {
            const opt = document.createElement('option');
            opt.value = model;
            opt.textContent = model;
            modelSelect.appendChild(opt);
          });
          console.log('‚úì Models dropdown populated with', d.models.length, 'models');
          const preferred = (d.current && (d.current.instruct || d.current.base)) || null;
          if (preferred && d.models.includes(preferred)) {
            modelSelect.value = preferred;
          } else if (modelSelect.options.length > 0) {
            modelSelect.selectedIndex = 0;
          }
        } else {
          modelSelect.innerHTML = '<option>No models available</option>';
          console.log('‚ö†Ô∏è No models found in API response');
        }
      } catch (e) {
        console.error('‚ùå Failed to load models (JS error):', e);
        modelSelect.innerHTML = '<option>Error loading models (JS error)</option>';
      }
    }

    async function loadSystemPrompts() {
      try {
        const r = await fetch('/api/system-prompts');
        const d = await r.json();
        systemPrompts = Array.isArray(d.prompts) ? d.prompts : [];

        // Reset dropdown, keep the custom/empty option
        systemPromptSelect.innerHTML = '<option value="">Custom / empty</option>';

        systemPrompts.forEach(prompt => {
          const opt = document.createElement('option');
          opt.value = prompt.id;
          opt.textContent = prompt.name;
          systemPromptSelect.appendChild(opt);
        });
      } catch (e) {
        console.error('Failed to load system prompts:', e);
      }
    }

    async function loadBenchmarks() {
      console.log('üîÑ Attempting to load benchmarks...');
      try {
        const r = await fetch('/api/energy-benchmarks');
        console.log('üì° Benchmarks API response status:', r.status);
        if (!r.ok) {
          const errorText = await r.text();
          console.error('‚ùå Benchmarks API request failed:', r.status, errorText);
          if (energyBenchmark) energyBenchmark.innerHTML = '<option>Error loading (API fail)</option>';
          return;
        }
        const d = await r.json();
        console.log('‚úì Benchmarks API response data:', d);
        if (energyBenchmark) {
          energyBenchmark.innerHTML = '';
          if (d.benchmarks && d.benchmarks.length > 0) {
            d.benchmarks.forEach(benchmark => {
              const opt = document.createElement('option');
              opt.value = benchmark.name;
              const isRapl =
                (benchmark.source && benchmark.source.toLowerCase().includes('rapl')) ||
                benchmark.name.toLowerCase().startsWith('rapl_');
              const labelPrefix = isRapl ? '[RAPL] ' : '';
              opt.textContent = `${labelPrefix}${benchmark.name} (${benchmark.watt_hours_per_1000_tokens} Wh / 1000 tokens)`;
              energyBenchmark.appendChild(opt);
            });
            console.log('‚úì Benchmarks dropdown populated with', d.benchmarks.length, 'benchmarks');
          } else {
            energyBenchmark.innerHTML = '<option>No benchmarks available</option>';
            console.log('‚ö†Ô∏è No benchmarks found in API response');
          }
        } else {
          console.log('‚ÑπÔ∏è energyBenchmark element not found, skipping population');
        }
      } catch (e) {
        console.error('‚ùå Failed to load benchmarks (JS error):', e);
        if (energyBenchmark) energyBenchmark.innerHTML = '<option>Error loading (JS error)</option>';
      }
    }

    async function loadBenchmarkSwitcher(valueToSelect = null) {
      try {
        const currentValue = benchmarkSwitcher.value;
        const r = await fetch('/api/energy-benchmarks');
        const d = await r.json();
        benchmarkSwitcher.innerHTML = '';

        let found = false;
        if (d.benchmarks && d.benchmarks.length > 0) {
          d.benchmarks.forEach(benchmark => {
            const opt = document.createElement('option');
            opt.value = benchmark.name;
            const isRapl =
              (benchmark.source && benchmark.source.toLowerCase().includes('rapl')) ||
              benchmark.name.toLowerCase().startsWith('rapl_');
            const labelPrefix = isRapl ? '[RAPL] ' : '';
            opt.textContent = `${labelPrefix}${benchmark.name} (${benchmark.watt_hours_per_1000_tokens} Wh / 1000 tokens)`;
            benchmarkSwitcher.appendChild(opt);

            if (valueToSelect && benchmark.name === valueToSelect) {
              found = true;
            } else if (!valueToSelect && benchmark.name === currentValue) {
              found = true;
            } else if (!valueToSelect && !currentValue && benchmark.name === 'conservative_estimate') {
              // Default to conservative_estimate
              found = true;
            }
          });

          // Set the value
          if (valueToSelect) {
            benchmarkSwitcher.value = valueToSelect;
          } else if (found && currentValue) {
            benchmarkSwitcher.value = currentValue;
          } else {
            // Default to conservative_estimate
            benchmarkSwitcher.value = 'conservative_estimate';
          }
        }

        switchBenchmarkBtn.disabled = false;
      } catch (e) {
        console.error('Failed to load benchmark switcher:', e);
        benchmarkSwitcher.innerHTML = '<option>Error loading benchmarks</option>';
      }
    }

    async function updateCurrentBenchmarkInfo() {
      try {
        const r = await fetch('/api/session-summary');
        const summary = await r.json();
        if (!summary.error && summary.benchmark_used) {
          const benchmarkName = summary.benchmark_used;
          currentBenchmarkInfo.textContent = `${benchmarkName} - Click info button for details`;
        } else {
          currentBenchmarkInfo.textContent = 'No benchmark selected';
        }
      } catch (e) {
        console.error('Failed to update current benchmark info:', e);
        currentBenchmarkInfo.textContent = 'Error loading benchmark info';
      }
    }

    function setupWebSocket() {
      const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
      ws = new WebSocket(`${wsProto}://${location.host}/ws`);

      ws.onopen = () => {
        if (connectionStatus) {
          connectionStatus.textContent = 'Connected';
          connectionStatus.className = 'px-4 py-2 rounded-full bg-green-100 text-green-700';
        }
      };

      ws.onclose = () => {
        if (connectionStatus) {
          connectionStatus.textContent = 'Disconnected';
          connectionStatus.className = 'px-4 py-2 rounded-full bg-red-100 text-red-700';
        }
      };

      ws.onmessage = async (event) => {
        const data = JSON.parse(event.data);
        console.log('üì© WebSocket message received:', data);

        if (data.log) {
          console.log('üéØ ROUTING LOG:', data.log);
          appendCliLog(data.log);
        } else if (data.token && !data.done) {
          // Streaming token
          console.log('üìù TOKEN RECEIVED:', data.token);
          console.log('üìç responseOutput element:', responseOutput);
          console.log('üìç Current responseOutput content length:', responseOutput.textContent.length);
          responseOutput.textContent += data.token;
          console.log('‚úÖ Updated responseOutput. New length:', responseOutput.textContent.length);
          // Also mirror tokens into CLI log when live logs are open
          appendCliLog(data.token);
        } else if (data.done) {
          console.log('‚úîÔ∏è Test completion received');
          await handleTestCompletion(data);
        } else if (data.error) {
          console.error('‚ùå Error from backend:', data.error);
          alert(`Error: ${data.error}`);
        } else {
          console.warn('‚ö†Ô∏è Unknown message type:', data);
        }
      };
    }

    function setupEventListeners() {
      temperature.addEventListener('input', () => tempValue.textContent = temperature.value);

      // Benchmark controls
      // Benchmark controls
      benchmarkInfoBtn.addEventListener('click', showBenchmarkInfo);
      switchBenchmarkBtn.addEventListener('click', switchBenchmark);
      addCustomBenchmarkBtn.addEventListener('click', addCustomBenchmark);
      if (runRaplCalibration) runRaplCalibration.addEventListener('click', runRaplCalibrationHandler);
      // runRaplBatch button removed (integrated into main run)

      // System prompt selection
      if (systemPromptSelect) {
        systemPromptSelect.addEventListener('change', () => {
          const id = systemPromptSelect.value;
          if (!id) {
            // Custom / empty
            return;
          }
          const found = systemPrompts.find(p => p.id === id);
          if (found && typeof found.content === 'string') {
            systemPromptText.value = found.content;
          }
        });
      }

      // Clear system prompt
      const clearSystemPromptBtn = document.getElementById('clearSystemPromptBtn');
      if (clearSystemPromptBtn) {
        clearSystemPromptBtn.addEventListener('click', () => {
          if (systemPromptSelect) systemPromptSelect.value = '';
          if (systemPromptText) systemPromptText.value = '';
        });
      }

      // Inject latest conversation into context
      const injectConversationBtn = document.getElementById('injectConversationBtn');
      if (injectConversationBtn && conversationContextText) {
        injectConversationBtn.addEventListener('click', () => {
          const userText = userPrompt.value.trim();
          const responseText = responseOutput.textContent.trim();
          if (!userText && !responseText) {
            return;
          }

          const blockLines = [];
          blockLines.push('<conversation_context>');
          if (userText) {
            blockLines.push('[User] ' + userText);
          }
          if (responseText) {
            blockLines.push('[Assistant] ' + responseText);
          }
          blockLines.push('</conversation_context>');

          const block = blockLines.join('\n');
          const existing = conversationContextText.value.trim();
          conversationContextText.value = existing ? (existing + '\n\n' + block) : block;
        });
      }

      runTest.addEventListener('click', runEnergyTest);
      stopTest.addEventListener('click', stopEnergyTest);
      clearResults.addEventListener('click', clearAllResults);
      exportData.addEventListener('click', exportSessionData);
      showLogs.addEventListener('click', openCliModal);
      closeCliModalBtn.addEventListener('click', closeCliModal);
    }

    function initChart() {
      const ctx = document.getElementById('energyChart').getContext('2d');
      energyChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Total Energy (Wh)',
              data: [],
              borderColor: 'rgb(59, 130, 246)', // Blue
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              yAxisID: 'y',
              tension: 0.1
            },
            {
              label: 'Intensity (Wh/1k e-tokens)',
              data: [],
              borderColor: 'rgb(147, 51, 234)', // Purple
              backgroundColor: 'rgba(147, 51, 234, 0.15)',
              yAxisID: 'y1',
              tension: 0.1
            }
          ]
        },
        options: {
          responsive: true,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          scales: {
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: { display: true, text: 'Total Energy (Wh)' }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: { display: true, text: 'Wh / 1000 Output Tokens' },
              grid: {
                drawOnChartArea: false, // only want the grid lines for one axis to show up
              },
            },
            x: {
              title: { display: true, text: 'Test Run' }
            }
          }
        }
      });
    }

    async function showBenchmarkInfo() {
      try {
        const r = await fetch('/api/benchmark-info');
        const data = await r.json();

        let info = 'Benchmark Information:\n\n';

        if (data.benchmarks) {
          info += 'Available Benchmarks:\n';
          data.benchmarks.forEach(b => {
            info += `‚Ä¢ ${b.name}: ${b.watt_hours_per_1000_tokens} Wh/1000 tokens\n`;
            info += `  ${b.description}\n`;
            if (b.source !== 'Custom') info += `  Source: ${b.source}\n`;
            if (b.hardware_specs) info += `  Hardware: ${b.hardware_specs}\n`;
            info += '\n';
          });
        }

        if (data.co2_info) {
          info += `CO2 Conversion: ${data.co2_info.global_average_gco2_per_kwh} gCO2/kWh\n`;
          info += `Source: ${data.co2_info.source}\n`;
          info += `Calculation: ${data.co2_info.calculation}\n\n`;
        }

        if (data.benchmark_sources) {
          info += 'Detailed Benchmark Sources:\n';
          Object.entries(data.benchmark_sources).forEach(([name, details]) => {
            info += `${name}:\n`;
            Object.entries(details).forEach(([key, value]) => {
              info += `  ${key}: ${value}\n`;
            });
            info += '\n';
          });
        }

        alert(info);
      } catch (e) {
        console.error('Failed to load benchmark info:', e);
        alert('Error loading benchmark information');
      }
    }

    async function switchBenchmark() {
      const selectedBenchmark = benchmarkSwitcher.value;
      if (!selectedBenchmark) {
        alert('Please select a benchmark');
        return;
      }

      try {
        switchBenchmarkBtn.disabled = true;
        switchBenchmarkBtn.textContent = 'Recalculating...';

        const r = await fetch('/api/switch-benchmark', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ benchmark_name: selectedBenchmark })
        });

        if (r.ok) {
          const result = await r.json();
          // Update the UI with recalculated values
          updateSessionWithRecalculatedData(result);
          await updateCurrentBenchmarkInfo();
          alert(`Successfully switched to ${result.benchmark_used} benchmark`);
        } else {
          const error = await r.json();
          alert(`Error switching benchmark: ${error.detail || 'Unknown error'}`);
        }
      } catch (e) {
        console.error('Failed to switch benchmark:', e);
        alert('Error switching benchmark');
      } finally {
        switchBenchmarkBtn.disabled = false;
        switchBenchmarkBtn.textContent = 'Recalculate with Selected Benchmark';
      }
    }

    async function addCustomBenchmark() {
      const name = customBenchmarkName.value.trim();
      const wattHours = parseFloat(customBenchmarkWattHours.value);
      const desc = customBenchmarkDesc.value.trim();
      const specs = customBenchmarkSpecs.value.trim();

      if (!name || !desc || isNaN(wattHours) || wattHours <= 0) {
        alert('Please fill in all required fields with valid values');
        return;
      }

      try {
        addCustomBenchmarkBtn.disabled = true;
        addCustomBenchmarkBtn.textContent = 'Adding...';

        const r = await fetch('/api/add-custom-benchmark', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            name: name,
            description: desc,
            watt_hours_per_1000_tokens: wattHours,
            hardware_specs: specs || undefined
          })
        });

        if (r.ok) {
          const result = await r.json();
          alert(result.message);

          // Clear form and reload benchmark options
          customBenchmarkName.value = '';
          customBenchmarkWattHours.value = '';
          customBenchmarkDesc.value = '';
          customBenchmarkSpecs.value = '';

          await loadBenchmarks();
          await loadBenchmarkSwitcher(name); // Select the new benchmark
        } else {
          const error = await r.json();
          alert(`Error adding benchmark: ${error.detail || 'Unknown error'}`);
        }
      } catch (e) {
        console.error('Failed to add custom benchmark:', e);
        alert('Error adding custom benchmark');
      } finally {
        addCustomBenchmarkBtn.disabled = false;
        addCustomBenchmarkBtn.textContent = 'Add Custom Benchmark';
      }
    }

    async function runRaplCalibrationHandler() {
      const runsInput = document.getElementById('raplCalibrationRuns');
      const statusEl = document.getElementById('raplCalibrationStatus');
      const statsContainer = document.getElementById('raplCalibrationStats');
      const runs = parseInt(runsInput.value, 10) || 1;

      const model = modelSelect.value;
      if (!model) {
        alert('Please select a model before running RAPL calibration.');
        return;
      }

      try {
        statusEl.textContent = `Running ${runs} RAPL calibration run(s)‚Ä¶ this may take a while.`;
        runRaplCalibration.disabled = true;

        const r = await fetch('/api/rapl-calibrate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ runs, model_name: model })
        });

        if (!r.ok) {
          const err = await r.json().catch(() => ({}));
          throw new Error(err.detail || 'Calibration failed');
        }

        const data = await r.json();
        const s = data.stats || {};
        const b = data.benchmark || {};

        document.getElementById('raplCalMean').textContent = (s.mean ?? 0).toFixed(6);
        document.getElementById('raplCalMedian').textContent = (s.median ?? 0).toFixed(6);
        document.getElementById('raplCalStd').textContent = (s.std ?? 0).toFixed(6);
        document.getElementById('raplCalP5').textContent = (s.p5 ?? 0).toFixed(6);
        document.getElementById('raplCalP95').textContent = (s.p95 ?? 0).toFixed(6);
        document.getElementById('raplCalCv').textContent = s.cv != null ? s.cv.toFixed(2) : '-';
        document.getElementById('raplCalBenchmarkName').textContent = b.name || '-';

        statsContainer.classList.remove('hidden');
        statusEl.textContent = `RAPL calibration complete. Created/updated benchmark '${b.name}'.`;

        // Refresh benchmark lists and auto-select the new calibrated benchmark
        await loadBenchmarks();
        await loadBenchmarkSwitcher(b.name);
        if (energyBenchmark) energyBenchmark.value = b.name;
      } catch (e) {
        console.error('RAPL calibration failed:', e);
        alert(`RAPL calibration failed: ${e.message}`);
        statusEl.textContent = 'RAPL calibration failed.';
      } finally {
        runRaplCalibration.disabled = false;
      }
    }

    // Build payload from current UI (system prompt + conversation context + query + injections + settings)
    function buildEnergyPayload(forceRapl = false) {
      const userQuery = userPrompt.value.trim();
      if (!userQuery) {
        throw new Error('Please enter a user query');
      }

      // Get raw components
      const baseSystem = systemPromptText.value.trim();
      const convoContext = conversationContextText ? conversationContextText.value.trim() : '';

      // Get structured injections
      const userInjections = getInjections().map(inj => ({
        description: inj.description,
        content: inj.content
      }));

      const payload = {
        // New structured fields for backend composition
        system_prompt: baseSystem,
        user_prompt: userQuery,
        conversation_context: convoContext,
        injections: userInjections,

        // Legacy fields (optional, but good to keep for now)
        system: baseSystem,
        user: userQuery,

        model_name: modelSelect.value,
        strategy_name: 'custom_injection',
        energy_benchmark: benchmarkSwitcher.value || 'conservative_estimate',
        injection_type: userInjections.length > 0 ? 'user_defined' : 'none',

        temp: parseFloat(temperature.value),
        max_tokens: parseInt(maxTokens.value),
        seed: document.getElementById('seedInput').value ? parseInt(document.getElementById('seedInput').value) : null,
        enable_live_power_monitoring: forceRapl ? true : (document.getElementById('enableLivePower')?.checked === true)
      };

      return payload;
    }

    function updateSessionWithRecalculatedData(recalculatedData) {
      // Update session summary display
      sessionEnergy.textContent = `${recalculatedData.total_energy_wh.toFixed(4)} Wh`;
      sessionCarbon.textContent = `${recalculatedData.total_carbon_gco2.toFixed(2)} gCO2`;
      sessionEfficiency.textContent = `${recalculatedData.average_energy_per_1000_tokens.toFixed(4)} Wh/1K`;
      sessionTokens.textContent = recalculatedData.total_tokens;
      if (sessionRaplEnergy && recalculatedData.session_summary?.rapl_session) {
        sessionRaplEnergy.textContent = `${recalculatedData.session_summary.rapl_session.toFixed(6)} Wh`;
      }

      // If we have current test results, update the energy display for the current test
      if (currentTestResults) {
        // Find the current test in the recalculated readings (last one)
        const currentTest = recalculatedData.readings[recalculatedData.readings.length - 1];
        if (currentTest) {
          testEnergy.textContent = `${currentTest.watt_hours_consumed.toFixed(4)} Wh`;
          carbonImpact.textContent = `${currentTest.carbon_grams_co2.toFixed(2)} gCO2`;

          // Update energy bar
          const energy = currentTest.watt_hours_consumed;
          let energyLevel = 'low';
          let barWidth = Math.min(energy * 10, 100); // Scale for visualization

          if (energy > 0.5) energyLevel = 'medium';
          if (energy > 1.0) energyLevel = 'high';

          testEnergyBar.style.width = `${barWidth}%`;
          testEnergyBar.className = `energy-bar energy-${energyLevel} h-4 rounded-full`;
        }
      }
    }

    // ===== INJECTION MANAGEMENT =====
    let injectionCounter = 0;
    const injections = [];

    function addInjection(description = '', content = '') {
      const id = `injection_${injectionCounter++}`;
      const injection = { id, description, content };
      injections.push(injection);

      const injectionHTML = `
        <div class="border rounded p-3 bg-gray-50" id="${id}">
          <div class="flex justify-between items-start mb-2">
            <input type="text" class="flex-1 p-1 border rounded text-sm injection-desc" 
                   placeholder="Injection Type (e.g., system_prompt, tool_results, memory, cot)" 
                   value="${description}">
            <button class="ml-2 text-red-600 hover:text-red-800 text-sm remove-injection" data-id="${id}">‚úï</button>
          </div>
          <textarea class="w-full p-2 border rounded text-sm injection-content" 
                    placeholder="Enter injection content...">${content}</textarea>
        </div>
      `;

      document.getElementById('injectionsContainer').insertAdjacentHTML('beforeend', injectionHTML);

      // Add event listeners
      document.querySelector(`#${id} .remove-injection`).addEventListener('click', function () {
        removeInjection(id);
      });
    }

    function removeInjection(id) {
      const index = injections.findIndex(inj => inj.id === id);
      if (index > -1) injections.splice(index, 1);
      document.getElementById(id).remove();
    }

    function getInjections() {
      const result = [];
      document.querySelectorAll('#injectionsContainer > div').forEach(div => {
        const desc = div.querySelector('.injection-desc').value;
        const content = div.querySelector('.injection-content').value;
        if (content.trim()) {
          result.push({ description: desc || 'Unnamed', content: content.trim() });
        }
      });
      return result;
    }

    // Add event listener for add button
    document.getElementById('addInjectionBtn').addEventListener('click', () => addInjection());

    // Note: no default injections; system prompt is controlled by the fixed field above.

    // ===== RUN TEST (UPDATED FOR NEW INJECTION SYSTEM & BATCH TRIGGER) =====
    async function runEnergyTest() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        alert('WebSocket not connected. Please refresh the page.');
        return;
      }

      if (!modelSelect.value || /No models/i.test(modelSelect.value)) {
        alert('No valid model selected. Start Ollama and pick a model.');
        return;
      }

      // Check for Batch Mode
      const liveChecked = document.getElementById('enableLivePower')?.checked === true;
      const batchRuns = parseInt(document.getElementById('raplBatchRuns').value) || 1;

      if (liveChecked && batchRuns > 1) {
        // Trigger Batch Handler instead
        await runRaplBatchHandler();
        return;
      }

      responseOutput.textContent = '';
      currentTestResults = null;
      if (cliLog) cliLog.innerHTML = '';

      if (liveChecked) openCliModal();

      let payload;
      try {
        payload = buildEnergyPayload(false);
      } catch (e) {
        alert(e.message);
        return;
      }

      // Brief CLI log to confirm injections
      const sysPreview = (payload.system || '').slice(0, 200).replace(/\n/g, ' ');
      appendCliLog(`üîß System prompt set (${payload.system?.length || 0} chars): ${sysPreview}${(payload.system && payload.system.length > 200) ? '‚Ä¶' : ''}`);
      appendCliLog(`üß© Injections meta: ${JSON.stringify(payload.injection_params?.metadata || {})}`);
      if (payload.seed) appendCliLog(`üé≤ Seed: ${payload.seed}`);

      console.log('üì§ Sending payload:', payload);

      ws.send(JSON.stringify(payload));
      runTest.disabled = true;
      runTest.innerHTML = '<span class="animate-spin mr-2">‚Üª</span> Running...';
      stopTest.disabled = false;
      stopTest.classList.remove('bg-gray-100', 'text-gray-400', 'cursor-not-allowed');
      stopTest.classList.add('btn-danger', 'hover:bg-red-700');
    }
    function stopEnergyTest() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        batchStopRequested = true;
        stopTest.disabled = true;
        stopTest.textContent = 'Stopping...';
        ws.send(JSON.stringify({ command: 'cancel' }));
      }
    }

    async function handleTestCompletion(data) {
      runTest.disabled = false;
      runTest.textContent = 'Run Energy Test';
      stopTest.disabled = true;
      stopTest.textContent = 'Stop Test';

      if (data.error) {
        alert(`Test failed: ${data.error}`);
        return;
      }

      // In batch mode, just stash the latest result and let the batch handler
      // decide when to update the main UI (only once at the end).
      if (batchRunning) {
        _raplLastBatchResult = data;
      } else {
        currentTestResults = data;

        // Update energy display
        updateEnergyDisplay(data.energy_metrics);

        // Update results display
        updateResultsDisplay(data);

        // Update chart
        updateEnergyChart(
          data.energy_metrics.watt_hours_consumed,
          data.energy_metrics.energy_efficiency_score
        );

        // Update session summary
        await updateSessionSummary();

        const usedBenchmark = data.energy_metrics.benchmark_used;
        if (usedBenchmark && usedBenchmark !== benchmarkSwitcher.value) {
          await loadBenchmarkSwitcher(usedBenchmark);
          await loadBenchmarks();
          if (energyBenchmark) {
            const opt = Array.from(energyBenchmark.options).find(o => o.value === usedBenchmark);
            if (opt) energyBenchmark.value = usedBenchmark;
          }
          const infoEl = document.getElementById('currentBenchmarkInfo');
          if (infoEl) infoEl.textContent = `${usedBenchmark} - Click info button for details`;
        }

        // Analyze modification impact
        analyzeModificationImpact(data);

        // If this was a single RAPL-enabled run with a valid measurement, record it into the RAPL table
        if (!batchRunning && data.live_power_metrics && data.live_power_metrics.measured_wh_per_1000_tokens != null) {
          const now = new Date();
          const ts = now.toLocaleTimeString();
          const raplWhPer1k = data.live_power_metrics.measured_wh_per_1000_tokens;
          const inTok = data.basic_metrics?.prompt_tokens ?? null;
          const outTok = data.basic_metrics?.completion_tokens ?? null;
          raplBatchSummaries.push({
            id: `${Date.now()}_${Math.random().toString(36).slice(2)}`,
            time: ts,
            runs: 1,
            meanWhPer1k: raplWhPer1k,
            medianWhPer1k: raplWhPer1k,
            stdWhPer1k: 0,
            p5WhPer1k: raplWhPer1k,
            p95WhPer1k: raplWhPer1k,
            cv: 0,
            meanInputTokens: inTok,
            medianInputTokens: inTok,
            meanOutputTokens: outTok,
            medianOutputTokens: outTok,
          });
          renderRaplBatchTable();
        }
      }

      // Resolve any pending batch run
      if (batchRunning && typeof window._raplBatchResolve === 'function') {
        const resolve = window._raplBatchResolve;
        window._raplBatchResolve = null;
        resolve(data);
      }
    }

    async function runRaplBatchHandler() {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        alert('WebSocket not connected. Please refresh the page.');
        return;
      }

      const runsInput = document.getElementById('raplBatchRuns');
      const totalRuns = parseInt(runsInput.value, 10) || 1;

      // Prepare CLI terminal
      if (cliLog) cliLog.innerHTML = '';
      openCliModal();
      appendCliLog(`üìä Starting RAPL batch: ${totalRuns} run(s) with current query + injections`);

      batchRunning = true;
      batchStopRequested = false;
      let completed = 0;
      const raplValues = [];
      const inputTokensArr = [];
      const outputTokensArr = [];
      _raplBatchFirstDuration = null;

      for (let i = 0; i < totalRuns; i++) {
        if (batchStopRequested) {
          appendCliLog(`‚èπ Batch stop requested after ${completed} run(s).`);
          break;
        }

        appendCliLog(`\n===== Batch Run ${i + 1}/${totalRuns} =====`);

        // Log current prompt and injections for this run
        const currentQuery = userPrompt.value.trim();
        appendCliLog(`üìù User query: ${currentQuery || '(empty)'}`);
        const injList = getInjections();
        if (injList.length > 0) {
          appendCliLog('üîß Injections:');
          injList.forEach((inj, idx) => {
            appendCliLog(`  [${idx + 1}] ${inj.description || 'Unnamed'}: ${inj.content.substring(0, 200)}${inj.content.length > 200 ? '‚Ä¶' : ''}`);
          });
        } else {
          appendCliLog('üîß Injections: (none)');
        }

        let payload;
        try {
          payload = buildEnergyPayload(true);
        } catch (e) {
          appendCliLog(`‚ùå Skipping run: ${e.message}`);
          break;
        }

        ws.send(JSON.stringify(payload));

        const data = await new Promise(resolve => {
          window._raplBatchResolve = resolve;
        });

        if (data && data.basic_metrics) {
          completed++;
          const totalTokens = data.basic_metrics.total_tokens;
          const promptTokens = data.basic_metrics.prompt_tokens ?? null;
          const completionTokens = data.basic_metrics.completion_tokens ?? null;
          const latency = data.basic_metrics.latency;
          const energyWh = data.energy_metrics.watt_hours_consumed;
          const raplWhPer1k = data.live_power_metrics && data.live_power_metrics.measured_wh_per_1000_tokens;

          if (raplWhPer1k != null) raplValues.push(raplWhPer1k);
          if (promptTokens != null) inputTokensArr.push(promptTokens);
          if (completionTokens != null) outputTokensArr.push(completionTokens);

          // Record first-run duration for ETA
          if (_raplBatchFirstDuration === null && latency && latency > 0) {
            _raplBatchFirstDuration = latency;
          }

          appendCliLog(
            `Run ${completed}: input=${promptTokens ?? 'n/a'} tok, output=${completionTokens ?? 'n/a'} tok, total=${totalTokens}, ` +
            `latency=${latency.toFixed(2)}s, energy=${energyWh.toFixed(3)} Wh, ` +
            `RAPL Wh/1K=${raplWhPer1k != null ? raplWhPer1k.toFixed(3) : 'n/a'}`
          );

          // Estimated remaining time based on first run
          if (_raplBatchFirstDuration !== null && completed < totalRuns) {
            const remainingRuns = totalRuns - completed;
            const etaSeconds = remainingRuns * _raplBatchFirstDuration;
            const minutes = Math.floor(etaSeconds / 60);
            const seconds = Math.round(etaSeconds % 60);
            appendCliLog(
              `  Approx. time remaining: ${minutes > 0 ? minutes + 'm ' : ''}${seconds}s for ${remainingRuns} run(s)`
            );
          }
        } else {
          appendCliLog('‚ö†Ô∏è Run returned no basic metrics; skipping from stats.');
        }
      }

      batchRunning = false;
      batchStopRequested = false;

      if (raplValues.length > 0) {
        const sorted = [...raplValues].sort((a, b) => a - b);
        const n = sorted.length;
        const mean = sorted.reduce((s, x) => s + x, 0) / n;
        const median = n % 2 === 1 ? sorted[(n - 1) / 2] : 0.5 * (sorted[n / 2 - 1] + sorted[n / 2]);
        const varVal = sorted.reduce((s, x) => s + (x - mean) * (x - mean), 0) / n;
        const std = Math.sqrt(varVal);
        const p5 = sorted[Math.max(Math.floor(n * 0.05) - 1, 0)];
        const p95 = sorted[Math.min(Math.floor(n * 0.95), n - 1)];
        const cv = std / mean;

        // Compute token statistics
        const meanIn = inputTokensArr.length ? (inputTokensArr.reduce((s, x) => s + x, 0) / inputTokensArr.length) : null;
        const meanOut = outputTokensArr.length ? (outputTokensArr.reduce((s, x) => s + x, 0) / outputTokensArr.length) : null;
        const medIn = inputTokensArr.length ? (() => {
          const t = [...inputTokensArr].sort((a,b)=>a-b); const n2 = t.length; return n2 % 2 ? t[(n2-1)/2] : 0.5*(t[n2/2-1]+t[n2/2]);
        })() : null;
        const medOut = outputTokensArr.length ? (() => {
          const t = [...outputTokensArr].sort((a,b)=>a-b); const n2 = t.length; return n2 % 2 ? t[(n2-1)/2] : 0.5*(t[n2/2-1]+t[n2/2]);
        })() : null;

        // Calculate injected tokens from the last result (assuming constant for batch)
        let injectedTokensVal = 0;
        if (_raplLastBatchResult && _raplLastBatchResult.token_metrics && _raplLastBatchResult.token_metrics.breakdown) {
          injectedTokensVal = _raplLastBatchResult.token_metrics.breakdown.injected?.total_injection_tokens || 0;
        }

        appendCliLog('\nüìà RAPL Batch Summary (UI prompt + injections)');
        appendCliLog(`  Successful runs: ${n}`);
        appendCliLog(`  Mean:   ${mean.toFixed(3)} Wh/1K`);
        appendCliLog(`  Median: ${median.toFixed(3)} Wh/1K`);
        appendCliLog(`  Std:    ${std.toFixed(3)} Wh/1K`);
        appendCliLog(`  5‚Äì95%:  ${p5.toFixed(3)} ‚Äì ${p95.toFixed(3)} Wh/1K`);
        appendCliLog(`  CV:     ${cv.toFixed(3)}`);
        if (meanIn != null || meanOut != null) {
          appendCliLog(`  Input tokens Œº: ${meanIn != null ? meanIn.toFixed(0) : 'n/a'}`);
          appendCliLog(`  Output tokens Œº: ${meanOut != null ? meanOut.toFixed(0) : 'n/a'}`);
        }
        if (injectedTokensVal > 0) {
          appendCliLog(`  Injected tokens: ${injectedTokensVal}`);
        }

        // Store a simple summary row for the batch table
        const now = new Date();
        const ts = now.toLocaleTimeString();
        raplBatchSummaries.push({
          id: `${Date.now()}_${Math.random().toString(36).slice(2)}`,
          time: ts,
          runs: n,
          injectedTokens: injectedTokensVal,
          meanWhPer1k: mean,
          medianWhPer1k: median,
          stdWhPer1k: std,
          p5WhPer1k: p5,
          p95WhPer1k: p95,
          cv,
          meanInputTokens: meanIn,
          medianInputTokens: medIn,
          meanOutputTokens: meanOut,
          medianOutputTokens: medOut,
        });
        renderRaplBatchTable();
      } else {
        appendCliLog('\n‚ö†Ô∏è No valid RAPL Wh/1K values collected in batch.');
      }

      // After batch completes, if we have a last successful result, apply it
      // to the main single-run UI so you can inspect one concrete run.
      if (_raplLastBatchResult) {
        currentTestResults = _raplLastBatchResult;
        updateEnergyDisplay(_raplLastBatchResult.energy_metrics);
        updateResultsDisplay(_raplLastBatchResult);
        updateEnergyChart(_raplLastBatchResult.energy_metrics.watt_hours_consumed, _raplLastBatchResult.energy_metrics.energy_efficiency_score);
        await updateSessionSummary();
        analyzeModificationImpact(_raplLastBatchResult);
      }
    }

    function updateEnergyDisplay(energyMetrics) {
      const energy = energyMetrics.watt_hours_consumed;
      const carbon = energyMetrics.carbon_grams_co2;

      testEnergy.textContent = `${energy.toFixed(3)} Wh`;
      testEnergy.textContent = `${energy.toFixed(4)} Wh`;
      carbonImpact.textContent = `${carbon.toFixed(2)} gCO2`;
      // Per-run RAPL metrics (if available on this response)
      if (currentTestResults && currentTestResults.live_power_metrics && currentTestResults.live_power_metrics.measured_wh) {
        if (currentTestResults.live_power_metrics.measured_wh_per_1000_tokens) {
          raplEfficiency.textContent = `${currentTestResults.live_power_metrics.measured_wh_per_1000_tokens.toFixed(4)} Wh/1K`;
        }
      } else {
        raplEfficiency.textContent = '0.00';
      }

      // Update energy bar
      let energyLevel = 'low';
      let barWidth = Math.min(energy * 10, 100); // Scale for visualization

      if (energy > 0.5) energyLevel = 'medium';
      if (energy > 1.0) energyLevel = 'high';

      testEnergyBar.style.width = `${barWidth}%`;
      testEnergyBar.className = `energy-bar energy-${energyLevel} h-4 rounded-full`;
    }

    let tokenChart = null;

    function updateResultsDisplay(data) {
      resultStrategy.textContent = data.strategy;
      resultTokens.textContent = data.basic_metrics.total_tokens;
      resultLatency.textContent = `${data.basic_metrics.latency.toFixed(2)}s`;
      resultTokensPerSec.textContent = data.basic_metrics.tokens_per_second.toFixed(1);

      // Update token breakdown display
      if (data.token_metrics && data.token_metrics.breakdown) {
        const breakdown = data.token_metrics.breakdown;
        const original = breakdown.original || {};
        const generation = breakdown.generation || {};
        const injected = breakdown.injected || {};

        const userTokens = original.total_original_tokens ?? 0;
        const outputTokens = generation.direct_output_tokens ?? 0;
        const injectionOverhead = injected.total_injection_tokens ?? 0;

        // Update summary text
        document.getElementById('inputTokensVal').textContent = userTokens;
        document.getElementById('overheadTokensVal').textContent = injectionOverhead;
        document.getElementById('outputTokensVal').textContent = outputTokens;

        if (Array.isArray(breakdown.analysis_notes) && breakdown.analysis_notes.length > 0) {
          tokenAnalysisNotes.textContent = breakdown.analysis_notes.join('. ') + '.';
        }

        // Update Chart
        const ctx = document.getElementById('tokenBreakdownChart').getContext('2d');

        if (tokenChart) {
          tokenChart.destroy();
        }

        tokenChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: ['Token Distribution'],
            datasets: [
              {
                label: 'User Input',
                data: [userTokens],
                backgroundColor: '#10b981', // Green
                barThickness: 40
              },
              {
                label: 'Injection Overhead',
                data: [injectionOverhead],
                backgroundColor: '#f59e0b', // Yellow
                barThickness: 40
              },
              {
                label: 'Model Output',
                data: [outputTokens],
                backgroundColor: '#3b82f6', // Blue
                barThickness: 40
              }
            ]
          },
          options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: { stacked: true, title: { display: true, text: 'Tokens' } },
              y: { stacked: true, display: false }
            },
            plugins: {
              legend: { position: 'top' },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    if (context.parsed.x !== null) {
                      label += context.parsed.x + ' tokens';
                    }
                    return label;
                  }
                }
              }
            }
          }
        });
      }

      efficiencyScore.textContent = data.energy_metrics.energy_efficiency_score.toFixed(4);
    }

    function updateEnergyChart(energyConsumption, intensity) {
      energyHistory.push({ energy: energyConsumption, intensity: intensity || 0 });
      if (energyHistory.length > 20) energyHistory.shift();

      energyChart.data.labels = energyHistory.map((_, i) => `Test ${i + 1}`);
      energyChart.data.datasets[0].data = energyHistory.map(h => h.energy);
      energyChart.data.datasets[1].data = energyHistory.map(h => h.intensity);
      energyChart.update();
    }

    function analyzeModificationImpact(data) {
      const modInfo = data.modification_info;
      const energyMetrics = data.energy_metrics;

      let impactText = '';

      if (modInfo.injection_overhead > 0) {
        const totalTokens = data.basic_metrics ? data.basic_metrics.total_tokens : null;
        const measuredWh = data.live_power_metrics && data.live_power_metrics.measured_wh ? data.live_power_metrics.measured_wh : null;
        const baseWh = measuredWh !== null ? measuredWh : energyMetrics.watt_hours_consumed;
        let energyOverhead = null;
        if (totalTokens && totalTokens > 0) {
          energyOverhead = baseWh * (modInfo.injection_overhead / totalTokens);
        }
        if (energyOverhead !== null) {
          impactText += `Prompt injection added ${modInfo.injection_overhead} tokens, which we estimate account for ~${energyOverhead.toFixed(6)} Wh of this run's energy. `;
        } else {
          impactText += `Prompt injection added ${modInfo.injection_overhead} tokens (energy impact estimate unavailable). `;
        }
      }

      if (modInfo.tool_integration_applied && modInfo.tool_integration_applied.total_tokens_added > 0) {
        impactText += `Tool integration added ${modInfo.tool_integration_applied.total_tokens_added} tokens from tool outputs. `;
      }

      if (!impactText) {
        impactText = 'No significant modifications detected.';
      }

      if (modificationImpact) {
        modificationImpact.textContent = impactText;
      }
    }

    async function updateSessionSummary() {
      try {
        const r = await fetch('/api/session-summary');
        const summary = await r.json();

        if (summary.error) return;

        sessionEnergy.textContent = `${summary.total_energy_wh.toFixed(4)} Wh`;
        sessionCarbon.textContent = `${summary.total_carbon_gco2.toFixed(2)} gCO2`;
        sessionEfficiency.textContent = `${summary.average_energy_per_1000_tokens.toFixed(4)} Wh/1K`;
        sessionTokens.textContent = summary.total_tokens;
      } catch (e) {
        console.error('Failed to update session summary:', e);
      }
    }

    function clearAllResults() {
      responseOutput.textContent = 'Run a test to see the model response here.';
      testEnergy.textContent = '0.00 Wh';
      testEnergyBar.style.width = '0%';
      efficiencyScore.textContent = '0.00';
      carbonImpact.textContent = '0.00';

      resultStrategy.textContent = '-';
      resultTokens.textContent = '-';
      resultLatency.textContent = '-';
      resultTokensPerSec.textContent = '-';

      // Clear token breakdown
      if (inputTokens) inputTokens.textContent = '-';
      if (outputTokens) outputTokens.textContent = '-';
      if (injectionTokens) injectionTokens.textContent = '-';
      if (toolTokens) toolTokens.textContent = '-';
      tokenAnalysisNotes.textContent = 'Run a test to see detailed token breakdown.';

      if (modificationImpact) {
        modificationImpact.textContent = 'Run a test to see energy impact analysis.';
      }

      // Clear chart
      energyHistory = [];
      energyChart.data.labels = [];
      energyChart.data.datasets[0].data = [];
      energyChart.update();
    }

    async function exportSessionData() {
      try {
        const r = await fetch('/api/export-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filepath: 'energy_test_session.json' })
        });

        if (r.ok) {
          alert('Session data exported to energy_test_session.json');
        } else {
          alert('Export failed');
        }
      } catch (e) {
        alert('Export error: ' + e.message);
      }
    }

    function openCliModal() {
      if (cliModal) cliModal.classList.remove('hidden');
    }

    function closeCliModal() {
      if (cliModal) cliModal.classList.add('hidden');
    }

    function appendCliLog(line) {
      if (!cliLog) return;
      const div = document.createElement('div');
      div.textContent = line;
      cliLog.appendChild(div);
      cliLog.scrollTop = cliLog.scrollHeight;
    }

    async function init() {
      // Load all data
      await loadModels();
      await loadBenchmarks();
      await loadBenchmarkSwitcher();
      await loadSystemPrompts();
      await updateCurrentBenchmarkInfo();
      await updateSessionSummary();

      // Setup UI
      setupWebSocket();
      setupEventListeners();
      initChart();
      renderRaplBatchTable();

      // Check connection
      if (ws && ws.readyState === WebSocket.OPEN && connectionStatus) {
        connectionStatus.textContent = 'Connected';
        connectionStatus.className = 'px-4 py-2 rounded-full bg-green-100 text-green-700';
      }
    }

    // Call init to start everything
    init();
  </script>
</body>

</html>